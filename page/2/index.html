<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>ZZONN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="www.zzonn.com">
<meta property="og:type" content="website">
<meta property="og:title" content="ZZONN">
<meta property="og:url" content="http://www.zzonn.com/page/2/index.html">
<meta property="og:site_name" content="ZZONN">
<meta property="og:description" content="www.zzonn.com">
<meta property="og:locale">
<meta property="article:author" content="LiPan">
<meta property="article:tag" content="ZZONN">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="ZZONN" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ZZONN</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">ZZONN</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.zzonn.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-dotnet源管理-dotnet-yuan-guan-li" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/31/dotnet%E6%BA%90%E7%AE%A1%E7%90%86-dotnet-yuan-guan-li/" class="article-date">
  <time class="dt-published" datetime="2021-03-31T09:35:35.851Z" itemprop="datePublished">2021-03-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Net/">.Net</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/31/dotnet%E6%BA%90%E7%AE%A1%E7%90%86-dotnet-yuan-guan-li/">dotnet源管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="源管理"><a href="#源管理" class="headerlink" title="源管理"></a>源管理</h2><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><p>列出当前目录中的已配置源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dotnet nuget list source</span><br><span class="line"></span><br><span class="line">Registered Sources:</span><br><span class="line">  1.  nuget.org [Disabled]</span><br><span class="line">      https://api.nuget.org/v3/index.json</span><br><span class="line">  2.  nuget.cnblogs [Enabled]</span><br><span class="line">      https://nuget.cnblogs.com/v3/index.json</span><br></pre></td></tr></table></figure>


<h3 id="添加新源地址"><a href="#添加新源地址" class="headerlink" title="添加新源地址"></a>添加新源地址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet nuget add source [地址] -n [名称]</span><br></pre></td></tr></table></figure>

<h3 id="删除指定源地址"><a href="#删除指定源地址" class="headerlink" title="删除指定源地址"></a>删除指定源地址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet nuget remove source [名称]</span><br></pre></td></tr></table></figure>

<h3 id="禁用指定源地址"><a href="#禁用指定源地址" class="headerlink" title="禁用指定源地址"></a>禁用指定源地址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet nuget disable source [名称]</span><br></pre></td></tr></table></figure>

<h3 id="启用指定源地址"><a href="#启用指定源地址" class="headerlink" title="启用指定源地址"></a>启用指定源地址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet nuget enable source [名称]</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.zzonn.com/2021/03/31/dotnet%E6%BA%90%E7%AE%A1%E7%90%86-dotnet-yuan-guan-li/" data-id="clf0jcv75001r6ocx98zqddq6" data-title="dotnet源管理" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/net/" rel="tag">.net</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/netcore/" rel="tag">.netcore</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tool/" rel="tag">Tool</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Ventoy（一款创建可启动USB驱动器的开源工具）-ventoy-yi-kuan-chuang-jian-ke-qi-dong-usb-qu-dong-qi-de-kai-yuan-gong-ju-" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/31/Ventoy%EF%BC%88%E4%B8%80%E6%AC%BE%E5%88%9B%E5%BB%BA%E5%8F%AF%E5%90%AF%E5%8A%A8USB%E9%A9%B1%E5%8A%A8%E5%99%A8%E7%9A%84%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7%EF%BC%89-ventoy-yi-kuan-chuang-jian-ke-qi-dong-usb-qu-dong-qi-de-kai-yuan-gong-ju-/" class="article-date">
  <time class="dt-published" datetime="2021-03-31T06:28:14.248Z" itemprop="datePublished">2021-03-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tool/">Tool</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/31/Ventoy%EF%BC%88%E4%B8%80%E6%AC%BE%E5%88%9B%E5%BB%BA%E5%8F%AF%E5%90%AF%E5%8A%A8USB%E9%A9%B1%E5%8A%A8%E5%99%A8%E7%9A%84%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7%EF%BC%89-ventoy-yi-kuan-chuang-jian-ke-qi-dong-usb-qu-dong-qi-de-kai-yuan-gong-ju-/">Ventoy（一款创建可启动USB驱动器的开源工具）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Ventoy是一个强大的免费开放源代码工具，用于为ISO &#x2F; IMG &#x2F; EFI和WIM文件创建可启动的USB驱动器。与当今市场上99％的闪存工具不同，Ventoy可以直接运行或重新安装即可启动文件。</p>
<p>这意味着你无需格式化优盘，用户只需要将所需的ISO镜像文件拷贝至优盘中即可在Ventoy界面中选择自己想要的ISO镜像文件。</p>
<p>Ventoy支持传统BIOS和UEFI，并结合了对GPT和MBR分区样式的支持。此外，它还能够支持任何ISO文件，它还支持大多数操作系统，包括Windows、Linux、Vmware、Unix、Xen和WinPE。</p>
<p>你需要注意的是，Ventoy会在第一次安装时对你的驱动器进行格式化，但之后你可以继续像往常一样使用你的闪存。除非你选择用NTFS&#x2F;FAT32&#x2F;UDF&#x2F;XFS&#x2F;Ext2等手动方式重新格式化它。</p>
<p>目前，目前已经测试了各类超过550+ 个ISO文件(列表)。支持 distrowatch.com 网站上收录的 90%+ 的操作系统(列表)。</p>
<p>Ventoy具有以下特性：</p>
<ul>
<li>免费和开源软件</li>
<li>两种ISO文件查看模式：列表和树</li>
<li>支持大于4GB的ISO文件</li>
<li>通过所有ISO文件的本机启动菜单样式以相同方式支持Legacy + UEFI</li>
<li>支持MBR和GPT分区样式</li>
<li>支持UEFI安全启动</li>
<li>支持持久性和自动安装</li>
<li>支持插件</li>
<li>支持文件注入</li>
<li>“ Ventoy兼容”概念，用于支持所有ISO文件</li>
<li>支持菜单别名&#x2F;菜单样式&#x2F;自定义菜单</li>
<li>支持文件注入和USB驱动器写保护</li>
</ul>
<h2 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a>安装说明</h2><ol>
<li><p>目前ventoy提供了windows和linux版本<br>下载地址：<a target="_blank" rel="noopener" href="https://github.com/ventoy/Ventoy/releases">https://github.com/ventoy/Ventoy/releases</a></p>
</li>
<li><p>以windows为例，解压后，运行Ventoy2Disk.exe，软件会自动搜索本地U盘；</p>
</li>
<li><p>接着点击安装，出现磁盘会被格式化的提示，点击是，然后就会安装成功了。</p>
</li>
<li><p>安装完成后，拷入所需要的ISO镜像文件，然后重启电脑并选择优盘启动，就可以看到Ventoy的主界面了，Ventoy支持传统Legacy引导和UEFI引导。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.zzonn.com/2021/03/31/Ventoy%EF%BC%88%E4%B8%80%E6%AC%BE%E5%88%9B%E5%BB%BA%E5%8F%AF%E5%90%AF%E5%8A%A8USB%E9%A9%B1%E5%8A%A8%E5%99%A8%E7%9A%84%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7%EF%BC%89-ventoy-yi-kuan-chuang-jian-ke-qi-dong-usb-qu-dong-qi-de-kai-yuan-gong-ju-/" data-id="clf0jcv6z00146ocx0aavavk0" data-title="Ventoy（一款创建可启动USB驱动器的开源工具）" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tool/" rel="tag">Tool</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-34 个 JavaScript 优化技巧-34个javascript优化技巧" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/26/34%20%E4%B8%AA%20JavaScript%20%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7-34%E4%B8%AAjavascript%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/" class="article-date">
  <time class="dt-published" datetime="2021-03-26T04:23:07.740Z" itemprop="datePublished">2021-03-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/26/34%20%E4%B8%AA%20JavaScript%20%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7-34%E4%B8%AAjavascript%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/">34 个 JavaScript 优化技巧</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>原文地址：34 JavaScript Optimization Techniques to Know in 2021<br>原文作者：atit53</p>
<p>可能你已经进行了多年的 JavaScript 开发工作，但有时候你还是会对一些最新的技术不那么了解，而这些新技术可能有助于某些问题的解决而不需要你去编写更多的代码。有时候，这些新技术也能帮助你进行代码优化。此外，如果你今年需要为 JavaScript 面试作准备，本文也是一份实用的参考资料。</p>
<p>在这里，我会介绍一些新的语法糖，它可以优化你的 JavaScript 代码，使代码更简洁。下面是一份 JavaScript 语法糖列表，你需要了解一下。</p>
<h2 id="1-含有多个条件的-if-语句"><a href="#1-含有多个条件的-if-语句" class="headerlink" title="1. 含有多个条件的 if 语句"></a>1. 含有多个条件的 if 语句</h2><p>我们可以在数组中存储多个值，并且可以使用数组的 includes 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//longhand</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="string">&#x27;abc&#x27;</span> || x === <span class="string">&#x27;def&#x27;</span> || x === <span class="string">&#x27;ghi&#x27;</span> || x ===<span class="string">&#x27;jkl&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">//logic</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//shorthand</span></span><br><span class="line"><span class="keyword">if</span> ([<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>].<span class="title function_">includes</span>(x)) &#123;</span><br><span class="line">   <span class="comment">//logic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-If-…-else-的缩写法"><a href="#2-If-…-else-的缩写法" class="headerlink" title="2. If … else 的缩写法"></a>2. If … else 的缩写法</h2><p>当我们的 if-else 条件中的逻辑比较简单时，可以使用这种简洁的方式——三元条件运算符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Longhand</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">test</span>: boolean;<span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    test = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    test = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Shorthand</span></span><br><span class="line"><span class="keyword">let</span> test = (x &gt; <span class="number">10</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//or we can use directly</span></span><br><span class="line"><span class="keyword">let</span> test = x &gt; <span class="number">10</span>;<span class="variable language_">console</span>.<span class="title function_">log</span>(test);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果包含嵌套的条件，我们也可以这样写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">300</span>,</span><br><span class="line">test2 = (x &gt; <span class="number">100</span>) ? <span class="string">&#x27;greater 100&#x27;</span> : (x &lt; <span class="number">50</span>) ? <span class="string">&#x27;less 50&#x27;</span> : <span class="string">&#x27;between 50 and 100&#x27;</span>;<span class="variable language_">console</span>.<span class="title function_">log</span>(test2); <span class="comment">// &quot;greater than 100&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-定义变量"><a href="#3-定义变量" class="headerlink" title="3. 定义变量"></a>3. 定义变量</h2><p>当我们定义两个值相同或类型相同的变量，可以使用这样的缩写法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Longhand </span></span><br><span class="line"><span class="keyword">let</span> test1;</span><br><span class="line"><span class="keyword">let</span> test2 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//Shorthand </span></span><br><span class="line"><span class="keyword">let</span> test1, test2 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="4-对-Null、Undefined、Empty-这些值的检查"><a href="#4-对-Null、Undefined、Empty-这些值的检查" class="headerlink" title="4. 对 Null、Undefined、Empty 这些值的检查"></a>4. 对 Null、Undefined、Empty 这些值的检查</h2><p>我们创建一个新变量，有时候需要检查是否为 Null 或 Undefined。JavaScript 本身就有一种缩写法能实现这种功能。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Longhand</span></span><br><span class="line"><span class="keyword">if</span> (test1 !== <span class="literal">null</span> || test1 !== <span class="literal">undefined</span> || test1 !== <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> test2 = test1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Shorthand</span></span><br><span class="line"><span class="keyword">let</span> test2 = test1 || <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="5-对-Null-值的检查以及默认赋值"><a href="#5-对-Null-值的检查以及默认赋值" class="headerlink" title="5. 对 Null 值的检查以及默认赋值"></a>5. 对 Null 值的检查以及默认赋值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test1 = <span class="literal">null</span>,</span><br><span class="line">    test2 = test1 || <span class="string">&#x27;&#x27;</span>;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;null check&quot;</span>, test2); <span class="comment">// output will be &quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-对-Undefined-值的检查以及默认赋值"><a href="#6-对-Undefined-值的检查以及默认赋值" class="headerlink" title="6. 对 Undefined 值的检查以及默认赋值"></a>6. 对 Undefined 值的检查以及默认赋值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test1 = <span class="literal">undefined</span>,</span><br><span class="line">    test2 = test1 || <span class="string">&#x27;&#x27;</span>;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;undefined check&quot;</span>, test2); <span class="comment">// output will be &quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>对正常值的检查</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test1 = <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">    test2 = test1 || <span class="string">&#x27;&#x27;</span>;<span class="variable language_">console</span>.<span class="title function_">log</span>(test2); <span class="comment">// output: &#x27;test&#x27;</span></span><br></pre></td></tr></table></figure>

<p>利好消息：关于第 4、5、6 条还可以使用 ?? 运算符</p>
<h2 id="聚合运算符"><a href="#聚合运算符" class="headerlink" title="聚合运算符"></a>聚合运算符</h2><p>??是聚合运算符，如果左值为 null 或 undefined，就返回右值。默认返回左值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test= <span class="literal">null</span> ?? <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test);</span><br><span class="line"><span class="comment">// expected output: &quot;default&quot;const test1 = 0 ?? 2;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test1);</span><br><span class="line"><span class="comment">// expected output: 0</span></span><br></pre></td></tr></table></figure>

<h2 id="7-同时为多个变量赋值"><a href="#7-同时为多个变量赋值" class="headerlink" title="7. 同时为多个变量赋值"></a>7. 同时为多个变量赋值</h2><p>当我们处理多个变量，并且需要对这些变量赋不同的值，这种缩写法很有用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Longhand </span></span><br><span class="line"><span class="keyword">let</span> test1, test2, test3;</span><br><span class="line">test1 = <span class="number">1</span>;</span><br><span class="line">test2 = <span class="number">2</span>;</span><br><span class="line">test3 = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//Shorthand </span></span><br><span class="line"><span class="keyword">let</span> [test1, test2, test3] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<h2 id="8-赋值运算符缩写法"><a href="#8-赋值运算符缩写法" class="headerlink" title="8. 赋值运算符缩写法"></a>8. 赋值运算符缩写法</h2><p>编程中使用算术运算符是很常见的情况。以下是 JavaScript 中赋值运算符的应用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Longhand</span></span><br><span class="line">test1 = test1 + <span class="number">1</span>;</span><br><span class="line">test2 = test2 - <span class="number">1</span>;</span><br><span class="line">test3 = test3 * <span class="number">20</span>;</span><br><span class="line"><span class="comment">// Shorthand</span></span><br><span class="line">test1++;</span><br><span class="line">test2--;</span><br><span class="line">test3 *= <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<h2 id="9-判断变量是否存在的缩写法"><a href="#9-判断变量是否存在的缩写法" class="headerlink" title="9. 判断变量是否存在的缩写法"></a>9. 判断变量是否存在的缩写法</h2><p>这是普遍使用的缩写法，但在这里应当提一下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Longhand</span></span><br><span class="line"><span class="keyword">if</span> (test1 === <span class="literal">true</span>) or <span class="keyword">if</span> (test1 !== <span class="string">&quot;&quot;</span>) or <span class="keyword">if</span> (test1 !== <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shorthand </span></span><br><span class="line"><span class="comment">//it will check empty string,null and undefined too</span></span><br><span class="line"><span class="keyword">if</span> (test1)</span><br></pre></td></tr></table></figure>

<p>注意：当 test1 为任何值时，程序都会执行 if(test1){ } 内的逻辑，这种写法在判断 NULL 或 undefined 值时普遍使用。</p>
<h2 id="10-用于多个条件的与-amp-amp-运算符"><a href="#10-用于多个条件的与-amp-amp-运算符" class="headerlink" title="10. 用于多个条件的与(&amp;&amp;)运算符"></a>10. 用于多个条件的与(&amp;&amp;)运算符</h2><p>如果需要实现某个变量为 true 时调用一个函数，可以使用 &amp;&amp; 运算符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Longhand </span></span><br><span class="line"><span class="keyword">if</span> (test1) &#123;</span><br><span class="line"> <span class="title function_">callMethod</span>(); </span><br><span class="line">&#125; <span class="comment">//Shorthand </span></span><br><span class="line">test1 &amp;&amp; <span class="title function_">callMethod</span>();</span><br></pre></td></tr></table></figure>

<h2 id="11-foreach-循环缩写法"><a href="#11-foreach-循环缩写法" class="headerlink" title="11. foreach 循环缩写法"></a>11. foreach 循环缩写法</h2><p>这是循环结构对应的缩写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Longhand</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; testData.<span class="property">length</span>; i++)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shorthand</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> testData) or  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> testData)</span><br></pre></td></tr></table></figure>

<p>Array for each variable</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testData</span>(<span class="params">element, index, array</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test[&#x27;</span> + index + <span class="string">&#x27;] = &#x27;</span> + element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">11</span>, <span class="number">24</span>, <span class="number">32</span>].<span class="title function_">forEach</span>(testData);</span><br><span class="line"><span class="comment">// logs: test[0] = 11, test[1] = 24, test[2] = 32</span></span><br></pre></td></tr></table></figure>

<h2 id="12-比较结果的返回"><a href="#12-比较结果的返回" class="headerlink" title="12. 比较结果的返回"></a>12. 比较结果的返回</h2><p>在 return 语句中，我们也可以使用比较的语句。这样，原来需要 5 行代码才能实现的功能，现在只需要 1 行，大大减少了代码量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Longhand</span></span><br><span class="line"><span class="keyword">let</span> test;<span class="keyword">function</span> <span class="title function_">checkReturn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(test === <span class="literal">undefined</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">callMe</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data = <span class="title function_">checkReturn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">//output testfunction callMe(val) &#123;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">&#125;<span class="comment">// Shorthandfunction checkReturn() &#123;</span></span><br><span class="line">    <span class="keyword">return</span> test || <span class="title function_">callMe</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-箭头函数"><a href="#13-箭头函数" class="headerlink" title="13. 箭头函数"></a>13. 箭头函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Longhand </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123; </span><br><span class="line">   <span class="keyword">return</span> a + b; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//Shorthand </span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a, b</span>) =&gt; a + b;</span><br></pre></td></tr></table></figure>
<p>再举个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callMe</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, name);</span><br><span class="line">&#125;callMe = <span class="function"><span class="params">name</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, name);</span><br></pre></td></tr></table></figure>

<h2 id="14-简短的函数调用语句"><a href="#14-简短的函数调用语句" class="headerlink" title="14. 简短的函数调用语句"></a>14. 简短的函数调用语句</h2><p>我们可以使用三元运算符实现如下功能。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Longhand</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test1&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test2&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> test3 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (test3 == <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="title function_">test1</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="title function_">test2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Shorthand</span></span><br><span class="line">(test3 === <span class="number">1</span>? <span class="attr">test1</span>:test2)();</span><br></pre></td></tr></table></figure>

<h2 id="15-switch-对应的缩写法"><a href="#15-switch-对应的缩写法" class="headerlink" title="15. switch 对应的缩写法"></a>15. switch 对应的缩写法</h2><p>我们可以把条件值保存在名值对中，基于这个条件使用名值对代替 switch。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Longhand</span></span><br><span class="line"><span class="keyword">switch</span> (data) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="title function_">test1</span>();</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="title function_">test2</span>();</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="title function_">test</span>();</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">// And so on...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shorthand</span></span><br><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">  <span class="number">1</span>: test1,</span><br><span class="line">  <span class="number">2</span>: test2,</span><br><span class="line">  <span class="number">3</span>: test</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">data[something] &amp;&amp; data[something]();</span><br></pre></td></tr></table></figure>

<h2 id="16-隐式返回缩写法"><a href="#16-隐式返回缩写法" class="headerlink" title="16. 隐式返回缩写法"></a>16. 隐式返回缩写法</h2><p>使用箭头函数，我们可以直接得到函数执行结果，不需要写 return 语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//longhand</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculate</span>(<span class="params">diameter</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * diameter</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//shorthand</span></span><br><span class="line">calculate = <span class="function"><span class="params">diameter</span> =&gt;</span> (</span><br><span class="line">  <span class="title class_">Math</span>.<span class="property">PI</span> * diameter;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="17-十进制数的指数形式"><a href="#17-十进制数的指数形式" class="headerlink" title="17. 十进制数的指数形式"></a>17. 十进制数的指数形式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Longhand</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shorthand</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1e4</span>; i++) &#123;</span><br></pre></td></tr></table></figure>

<h2 id="18-默认参数值"><a href="#18-默认参数值" class="headerlink" title="18. 默认参数值"></a>18. 默认参数值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Longhand</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">test1, test2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (test1 === <span class="literal">undefined</span>)</span><br><span class="line">    test1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (test2 === <span class="literal">undefined</span>)</span><br><span class="line">    test2 = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> test1 + test2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//shorthand</span></span><br><span class="line">add = <span class="function">(<span class="params">test1 = <span class="number">1</span>, test2 = <span class="number">2</span></span>) =&gt;</span> (test1 + test2);<span class="title function_">add</span>() <span class="comment">//output: 3</span></span><br></pre></td></tr></table></figure>

<h2 id="19-延展操作符的缩写法"><a href="#19-延展操作符的缩写法" class="headerlink" title="19. 延展操作符的缩写法"></a>19. 延展操作符的缩写法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//longhand// joining arrays using concat</span></span><br><span class="line"><span class="keyword">const</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> test = [<span class="number">4</span> ,<span class="number">5</span> , <span class="number">6</span>].<span class="title function_">concat</span>(data);</span><br><span class="line"><span class="comment">//shorthand// joining arrays</span></span><br><span class="line"><span class="keyword">const</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> test = [<span class="number">4</span> ,<span class="number">5</span> , <span class="number">6</span>, ...data];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test); <span class="comment">// [ 4, 5, 6, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>我们也可以使用延展操作符来克隆。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//longhand</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cloning arrays</span></span><br><span class="line"><span class="keyword">const</span> test1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> test2 = test1.<span class="title function_">slice</span>()</span><br><span class="line"><span class="comment">//shorthand</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cloning arrays</span></span><br><span class="line"><span class="keyword">const</span> test1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> test2 = [...test1];</span><br></pre></td></tr></table></figure>

<h2 id="20-文本模板"><a href="#20-文本模板" class="headerlink" title="20. 文本模板"></a>20. 文本模板</h2><p>如果你对使用 + 符号来连接多个变量感到厌烦，这个缩写法可以帮到你。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//longhand</span></span><br><span class="line"><span class="keyword">const</span> welcome = <span class="string">&#x27;Hi &#x27;</span> + test1 + <span class="string">&#x27; &#x27;</span> + test2 + <span class="string">&#x27;.&#x27;</span></span><br><span class="line"><span class="comment">//shorthand</span></span><br><span class="line"><span class="keyword">const</span> welcome = <span class="string">`Hi <span class="subst">$&#123;test1&#125;</span> <span class="subst">$&#123;test2&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<h2 id="21-跟多行文本有关的缩写法"><a href="#21-跟多行文本有关的缩写法" class="headerlink" title="21. 跟多行文本有关的缩写法"></a>21. 跟多行文本有关的缩写法</h2><p>当我们在代码中处理多行文本时，可以使用这样的技巧</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//longhand</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="string">&#x27;abc abc abc abc abc abc\n\t&#x27;</span></span><br><span class="line">    + <span class="string">&#x27;test test,test test test test\n\t&#x27;</span></span><br><span class="line"><span class="comment">//shorthand</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="string">`abc abc abc abc abc abc</span></span><br><span class="line"><span class="string">         test test,test test test test`</span></span><br></pre></td></tr></table></figure>

<h2 id="22-对象属性的赋值"><a href="#22-对象属性的赋值" class="headerlink" title="22. 对象属性的赋值"></a>22. 对象属性的赋值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test1 = <span class="string">&#x27;a&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> test2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="comment">//Longhand </span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">test1</span>: test1, <span class="attr">test2</span>: test2&#125;; </span><br><span class="line"><span class="comment">//Shorthand </span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;test1, test2&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="23-字符串转换为数字"><a href="#23-字符串转换为数字" class="headerlink" title="23. 字符串转换为数字"></a>23. 字符串转换为数字</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Longhand </span></span><br><span class="line"><span class="keyword">let</span> test1 = <span class="built_in">parseInt</span>(<span class="string">&#x27;123&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> test2 = <span class="built_in">parseFloat</span>(<span class="string">&#x27;12.3&#x27;</span>); </span><br><span class="line"><span class="comment">//Shorthand </span></span><br><span class="line"><span class="keyword">let</span> test1 = +<span class="string">&#x27;123&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> test2 = +<span class="string">&#x27;12.3&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="24-解构赋值缩写法"><a href="#24-解构赋值缩写法" class="headerlink" title="24. 解构赋值缩写法"></a>24. 解构赋值缩写法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//longhand</span></span><br><span class="line"><span class="keyword">const</span> test1 = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">test1</span>;</span><br><span class="line"><span class="keyword">const</span> test2 = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">test2</span>;</span><br><span class="line"><span class="keyword">const</span> test2 = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">test3</span>;</span><br><span class="line"><span class="comment">//shorthand</span></span><br><span class="line"><span class="keyword">const</span> &#123; test1, test2, test3 &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;</span><br></pre></td></tr></table></figure>

<h2 id="25-Array-find-缩写法"><a href="#25-Array-find-缩写法" class="headerlink" title="25. Array.find 缩写法"></a>25. Array.find 缩写法</h2><p>当我们需要在一个对象数组中按属性值查找特定对象时，find 方法很有用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;test1&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;test2&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;cde&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;test1&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;fgh&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">]<span class="keyword">function</span> <span class="title function_">findtest1</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[i].<span class="property">type</span> === <span class="string">&#x27;test1&#x27;</span> &amp;&amp; data[i].<span class="property">name</span> === name) &#123;</span><br><span class="line">            <span class="keyword">return</span> data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Shorthand</span></span><br><span class="line">filteredData = data.<span class="title function_">find</span>(<span class="function"><span class="params">data</span> =&gt;</span> data.<span class="property">type</span> === <span class="string">&#x27;test1&#x27;</span> &amp;&amp; data.<span class="property">name</span> === <span class="string">&#x27;fgh&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filteredData); <span class="comment">// &#123; type: &#x27;test1&#x27;, name: &#x27;fgh&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="26-查询条件缩写法"><a href="#26-查询条件缩写法" class="headerlink" title="26. 查询条件缩写法"></a>26. 查询条件缩写法</h2><p>如果我们要检查类型，并根据类型调用不同的函数，我们既可以使用多个 else if 语句，也可以使用 switch，除此之外，如果有缩写法，代码会是怎么样呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Longhand</span></span><br><span class="line"><span class="keyword">if</span> (type === <span class="string">&#x27;test1&#x27;</span>) &#123;</span><br><span class="line">  <span class="title function_">test1</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&#x27;test2&#x27;</span>) &#123;</span><br><span class="line">  <span class="title function_">test2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&#x27;test3&#x27;</span>) &#123;</span><br><span class="line">  <span class="title function_">test3</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&#x27;test4&#x27;</span>) &#123;</span><br><span class="line">  <span class="title function_">test4</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Invalid value &#x27;</span> + type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Shorthand</span></span><br><span class="line"><span class="keyword">var</span> types = &#123;</span><br><span class="line">  <span class="attr">test1</span>: test1,</span><br><span class="line">  <span class="attr">test2</span>: test2,</span><br><span class="line">  <span class="attr">test3</span>: test3,</span><br><span class="line">  <span class="attr">test4</span>: test4</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> func = types[type];</span><br><span class="line">(!func) &amp;&amp; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Invalid value &#x27;</span> + type); <span class="title function_">func</span>();</span><br></pre></td></tr></table></figure>

<h2 id="27-按位非和-indexOf-缩写法"><a href="#27-按位非和-indexOf-缩写法" class="headerlink" title="27. 按位非和 indexOf 缩写法"></a>27. 按位非和 indexOf 缩写法</h2><p>我们以查找特定值为目的迭代一个数组，通常用到 indexOf() 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//longhand</span></span><br><span class="line"><span class="keyword">if</span>(arr.<span class="title function_">indexOf</span>(item) &gt; -<span class="number">1</span>) &#123; <span class="comment">// item found </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(arr.<span class="title function_">indexOf</span>(item) === -<span class="number">1</span>) &#123; <span class="comment">// item not found</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//shorthand</span></span><br><span class="line"><span class="keyword">if</span>(~arr.<span class="title function_">indexOf</span>(item)) &#123; <span class="comment">// item found</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!~arr.<span class="title function_">indexOf</span>(item)) &#123; <span class="comment">// item not found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对除 <code>-1</code> 外的任何数进行 <code>按位非(~)</code> 运算都会返回真值。把按位非的结果再次进行逻辑取反就是 <code>!~</code>，这非常简单。或者我们也可以使用 <code>includes()</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.<span class="title function_">includes</span>(item)) &#123; </span><br><span class="line"><span class="comment">// true if the item found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="28-Object-entries"><a href="#28-Object-entries" class="headerlink" title="28. Object.entries()"></a>28. Object.entries()</h2><p>该特性可以把对象转换成一个由若干对象组成的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">test1</span>: <span class="string">&#x27;abc&#x27;</span>, <span class="attr">test2</span>: <span class="string">&#x27;cde&#x27;</span>, <span class="attr">test3</span>: <span class="string">&#x27;efg&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> arr = <span class="title class_">Object</span>.<span class="title function_">entries</span>(data);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);<span class="comment">/** Output:</span></span><br><span class="line"><span class="comment">[ [ &#x27;test1&#x27;, &#x27;abc&#x27; ],</span></span><br><span class="line"><span class="comment">  [ &#x27;test2&#x27;, &#x27;cde&#x27; ],</span></span><br><span class="line"><span class="comment">  [ &#x27;test3&#x27;, &#x27;efg&#x27; ]</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>

<h2 id="29-Object-values"><a href="#29-Object-values" class="headerlink" title="29. Object.values()"></a>29. Object.values()</h2><p>这也是 ES8 中介绍的一个新特性，它的功能与 Object.entries() 类似，但没有其核心功能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">test1</span>: <span class="string">&#x27;abc&#x27;</span>, <span class="attr">test2</span>: <span class="string">&#x27;cde&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> arr = <span class="title class_">Object</span>.<span class="title function_">values</span>(data);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);<span class="comment">/** Output:</span></span><br><span class="line"><span class="comment">[ &#x27;abc&#x27;, &#x27;cde&#x27;]</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>

<h2 id="30-两个位运算符缩写"><a href="#30-两个位运算符缩写" class="headerlink" title="30. 两个位运算符缩写"></a>30. 两个位运算符缩写</h2><p><strong>(两个按位非运算符只适用于 32 位整型)</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Longhand</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">1.9</span>) === <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Shorthand</span></span><br><span class="line">~~<span class="number">1.9</span> === <span class="number">1</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="31-把一个字符串重复多次"><a href="#31-把一个字符串重复多次" class="headerlink" title="31. 把一个字符串重复多次"></a>31. 把一个字符串重复多次</h2><p>我们可以使用 for 循环把一个字符串反复输出多次，那这种功能有没有缩写法呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//longhand </span></span><br><span class="line"><span class="keyword">let</span> test = <span class="string">&#x27;&#x27;</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123; </span><br><span class="line">  test += <span class="string">&#x27;test &#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str); <span class="comment">// test test test test test </span></span><br><span class="line"><span class="comment">//shorthand </span></span><br><span class="line"><span class="string">&#x27;test &#x27;</span>.<span class="title function_">repeat</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h2 id="32-找出一个数组中最大和最小的值"><a href="#32-找出一个数组中最大和最小的值" class="headerlink" title="32. 找出一个数组中最大和最小的值"></a>32. 找出一个数组中最大和最小的值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(…arr); <span class="comment">// 3</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">min</span>(…arr); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h2 id="33-获取字符串中的字符"><a href="#33-获取字符串中的字符" class="headerlink" title="33. 获取字符串中的字符"></a>33. 获取字符串中的字符</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="comment">//Longhand </span></span><br><span class="line">str.<span class="title function_">charAt</span>(<span class="number">2</span>); <span class="comment">// c</span></span><br><span class="line"><span class="comment">//Shorthand </span></span><br><span class="line"><span class="comment">//注意：如果事先知道目标字符在字符串中的索引，我们可以直接使用该索引值。如果索引值不确定，运行时就有可能抛出 undefined。</span></span><br><span class="line">str[<span class="number">2</span>]; <span class="comment">// c</span></span><br></pre></td></tr></table></figure>

<h2 id="34-幂运算的缩写法"><a href="#34-幂运算的缩写法" class="headerlink" title="34. 幂运算的缩写法"></a>34. 幂运算的缩写法</h2><p>指数幂函数的缩写法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//longhand</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// 8</span></span><br><span class="line"><span class="comment">//shorthand</span></span><br><span class="line"><span class="number">2</span>**<span class="number">3</span> <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.zzonn.com/2021/03/26/34%20%E4%B8%AA%20JavaScript%20%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7-34%E4%B8%AAjavascript%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/" data-id="clf0jcv6d00006ocx5qi506er" data-title="34 个 JavaScript 优化技巧" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-真香！微软出Go语言教程了-真香微软出go语言教程了" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/17/%E7%9C%9F%E9%A6%99%EF%BC%81%E5%BE%AE%E8%BD%AF%E5%87%BAGo%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B%E4%BA%86-%E7%9C%9F%E9%A6%99%E5%BE%AE%E8%BD%AF%E5%87%BAgo%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B%E4%BA%86/" class="article-date">
  <time class="dt-published" datetime="2021-03-17T03:39:29.489Z" itemprop="datePublished">2021-03-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Other/">Other</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/17/%E7%9C%9F%E9%A6%99%EF%BC%81%E5%BE%AE%E8%BD%AF%E5%87%BAGo%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B%E4%BA%86-%E7%9C%9F%E9%A6%99%E5%BE%AE%E8%BD%AF%E5%87%BAgo%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B%E4%BA%86/">真香！微软出Go语言教程了</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>课程地址：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/learn/paths/go-first-steps/">https://docs.microsoft.com/zh-cn/learn/paths/go-first-steps/</a></p>
<p>最近，有一项关于Go开发者的调查报告发布，这份报告的主要亮点有以下几点：</p>
<ul>
<li>总体满意度很高，有 92％ 的受访者对使用 Go感到满意</li>
<li>Go的使用在工作场所和企业中正在不断扩大，有76％的受访者在工作中使用 Go</li>
<li>Go继续被大量用于API、CLI、Web、DevOps和数据处理</li>
</ul>
<p>简而言之，就是一句话，Go编程语言越来越受欢迎了，如果你最近也正想学习这门语言，那真是来对地方了，最新上传了一个Go教程，最关键的是还有中文版。</p>
<p>通过这份教程，你可以 了解使用 Go 编译简单程序所需的基本语法和思维过程。</p>
<p>在此学习路径下，你将：</p>
<ul>
<li>安装编写第一行 Go 代码所需的工具。</li>
<li>了解如何在 Go 中使用控制流。</li>
<li>了解 Go 的数据类型。</li>
<li>了解如何处理错误。</li>
<li>使用方法和接口</li>
<li>了解 Go 中并发的工作原理。</li>
<li>编写并测试程序</li>
</ul>
<p>不过学习这门教程之前，先确保自己至少熟悉一门编程语言，以及一些常规的编程基础知识。</p>
<p>课程地址：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/learn/paths/go-first-steps/">https://docs.microsoft.com/zh-cn/learn/paths/go-first-steps/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.zzonn.com/2021/03/17/%E7%9C%9F%E9%A6%99%EF%BC%81%E5%BE%AE%E8%BD%AF%E5%87%BAGo%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B%E4%BA%86-%E7%9C%9F%E9%A6%99%E5%BE%AE%E8%BD%AF%E5%87%BAgo%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B%E4%BA%86/" data-id="clf0jcv7b002c6ocx69a4835c" data-title="真香！微软出Go语言教程了" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/" rel="tag">Go</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-C# 9.0 新特性-c90新特性" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/01/C#%209.0%20%E6%96%B0%E7%89%B9%E6%80%A7-c90%E6%96%B0%E7%89%B9%E6%80%A7/" class="article-date">
  <time class="dt-published" datetime="2020-11-01T09:55:13.000Z" itemprop="datePublished">2020-11-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Net/">.Net</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/01/C#%209.0%20%E6%96%B0%E7%89%B9%E6%80%A7-c90%E6%96%B0%E7%89%B9%E6%80%A7/">C# 9.0 新特性</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="简化-模式匹配"><a href="#简化-模式匹配" class="headerlink" title="简化 模式匹配"></a>简化 模式匹配</h2><p>模式匹配（Pattern Matching）是在 C# 7.0 引入的，是对 switch 语句的增强，可以支持实现复杂的条件匹配。下面我先用一个示例来展示一下模式匹配的一般的用法。</p>
<p>假如现在我们要计算各种车辆在某高速的通行费，比如有下面四种车辆，分别定义为以下四个类，各个类中定义了和通行费计算相关的属性：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Passengers &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DeliveryTruck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> GrossWeightClass &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Taxi</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Fares &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bus</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Capacity &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Riders &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面用用模式匹配的方式来实现一个计算通行费的方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">decimal</span> <span class="title">CalculateToll</span>(<span class="params"><span class="built_in">object</span> vehicle</span>)</span> =&gt;</span><br><span class="line">    vehicle <span class="keyword">switch</span></span><br><span class="line">&#123;</span><br><span class="line">    Car &#123; Passengers: <span class="number">0</span>&#125;        =&gt; <span class="number">2.00</span>m + <span class="number">0.50</span>m,</span><br><span class="line">    Car &#123; Passengers: <span class="number">1</span>&#125;        =&gt; <span class="number">2.0</span>m,</span><br><span class="line">    Car &#123; Passengers: <span class="number">2</span>&#125;        =&gt; <span class="number">2.0</span>m - <span class="number">0.50</span>m,</span><br><span class="line">    Car c                       =&gt; <span class="number">2.00</span>m - <span class="number">1.0</span>m,</span><br><span class="line"></span><br><span class="line">    Taxi t =&gt; t.Fares <span class="keyword">switch</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">0</span> =&gt; <span class="number">3.50</span>m + <span class="number">1.00</span>m,</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="number">3.50</span>m,</span><br><span class="line">        <span class="number">2</span> =&gt; <span class="number">3.50</span>m - <span class="number">0.50</span>m,</span><br><span class="line">        _ =&gt; <span class="number">3.50</span>m - <span class="number">1.00</span>m</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="function">Bus b <span class="title">when</span> (<span class="params">(<span class="built_in">double</span></span>)b.Riders / (<span class="params"><span class="built_in">double</span></span>)b.Capacity) &lt; 0.50</span> =&gt; <span class="number">5.00</span>m + <span class="number">2.00</span>m,</span><br><span class="line">    <span class="function">Bus b <span class="title">when</span> (<span class="params">(<span class="built_in">double</span></span>)b.Riders / (<span class="params"><span class="built_in">double</span></span>)b.Capacity) &gt; 0.90</span> =&gt; <span class="number">5.00</span>m - <span class="number">1.00</span>m,</span><br><span class="line">    Bus b =&gt; <span class="number">5.00</span>m,</span><br><span class="line"></span><br><span class="line">    <span class="function">DeliveryTruck t <span class="title">when</span> (<span class="params">t.GrossWeightClass &gt; <span class="number">5000</span></span>)</span> =&gt; <span class="number">10.00</span>m + <span class="number">5.00</span>m,</span><br><span class="line">    <span class="function">DeliveryTruck t <span class="title">when</span> (<span class="params">t.GrossWeightClass &lt; <span class="number">3000</span></span>)</span> =&gt; <span class="number">10.00</span>m - <span class="number">2.00</span>m,</span><br><span class="line">    DeliveryTruck _ =&gt; <span class="number">10.00</span>m,</span><br><span class="line"></span><br><span class="line">    &#123; &#125; =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(message: <span class="string">&quot;Not a known vehicle type&quot;</span>, paramName: <span class="keyword">nameof</span>(vehicle)),</span><br><span class="line">    <span class="literal">null</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(vehicle))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>实现这个业务逻辑，若在 C# 7.0 之前，需要用一堆的 if&#x2F;else 来实现。有了模式匹配后，变得方便了很多，而且使用上很灵活，代码结构也更优美。</p>
<p>对我来说，模式匹配是个极好的特性！但这还不够，C# 9.0 对模式匹配的写法做了进一步的简化！</p>
<p>以上面代码为例，模式匹配可以分为三种：简单模式、关系模式和逻辑模式。下面分别说说 C# 9.0 对三种模式的简化。</p>
<h3 id="简单模式"><a href="#简单模式" class="headerlink" title="简单模式"></a>简单模式</h3><p>以上面 CalculateToll 方法示例代码为例，简单模式对应的代码片段是这样的：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vehicle <span class="keyword">switch</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    Car c =&gt; <span class="number">2.00</span>m - <span class="number">1.0</span>m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们其实可以发现，上面的变量 c 声明了却没用被使用，现在 C# 9.0 中可以把它省略了：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vehicle <span class="keyword">switch</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    Car =&gt; <span class="number">2.00</span>m - <span class="number">1.0</span>m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h3><p>以上面 CalculateToll 方法示例代码为例，关系模式是通过比较（大小）关系来匹配的，对应的代码片段如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DeliveryTruck t <span class="title">when</span> (<span class="params">t.GrossWeightClass &gt; <span class="number">5000</span></span>)</span> =&gt; <span class="number">10.00</span>m + <span class="number">5.00</span>m,</span><br><span class="line"><span class="function">DeliveryTruck t <span class="title">when</span> (<span class="params">t.GrossWeightClass &lt; <span class="number">3000</span></span>)</span> =&gt; <span class="number">10.00</span>m - <span class="number">2.00</span>m,</span><br></pre></td></tr></table></figure>
<p>现在 C# 9.0 可以简写成：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DeliveryTruck t <span class="keyword">when</span> t.GrossWeightClass <span class="keyword">switch</span></span><br><span class="line">&#123;</span><br><span class="line">    &gt; <span class="number">5000</span> =&gt; <span class="number">10.00</span>m + <span class="number">5.00</span>m,</span><br><span class="line">    &lt; <span class="number">3000</span> =&gt; <span class="number">10.00</span>m - <span class="number">2.00</span>m,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="逻辑模式"><a href="#逻辑模式" class="headerlink" title="逻辑模式"></a>逻辑模式</h3><p>在 C# 9.0 中，你可以通过逻辑操作符 and、or 和 not 对模式进行组合，下面是一些示例：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DeliveryTruck t <span class="keyword">when</span> t.GrossWeightClass <span class="keyword">switch</span></span><br><span class="line">&#123;</span><br><span class="line">    &lt; <span class="number">3000</span> =&gt; <span class="number">10.00</span>m - <span class="number">2.00</span>m,</span><br><span class="line">    &gt;= <span class="number">3000</span> <span class="keyword">and</span> &lt;= <span class="number">5000</span> =&gt; <span class="number">10.00</span>m,</span><br><span class="line">    &gt; <span class="number">5000</span> =&gt; <span class="number">10.00</span>m + <span class="number">5.00</span>m,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">not</span> <span class="literal">null</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">$&quot;Not a known vehicle type: <span class="subst">&#123;vehicle&#125;</span>&quot;</span>, <span class="keyword">nameof</span>(vehicle)),</span><br><span class="line"><span class="literal">null</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(vehicle))</span><br></pre></td></tr></table></figure>
<p>另外，not 关键字还可以用来替代 if 条件判断中的逻辑非(!)，比如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原来的写法</span></span><br><span class="line"><span class="keyword">if</span> (!(e <span class="keyword">is</span> Customer)) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的写法（易读性更好）</span></span><br><span class="line"><span class="keyword">if</span> (e <span class="keyword">is</span> <span class="keyword">not</span> Customer) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h2 id="简化-参数非空检查"><a href="#简化-参数非空检查" class="headerlink" title="简化 参数非空检查"></a>简化 参数非空检查</h2><p>参数非空检查是编写类库很常见的操作，在一个方法中要求参数不能为空，否则抛出相应的异常。比如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">HashPassword</span>(<span class="params"><span class="built_in">string</span> password</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(password <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(password));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当异常发生时，调用者很容易知道是什么问题。如果不加这个检查，可能就会由系统抛出未将对象引用为实例之类的错误，这不利于调用者诊断错误。</p>
<p>由于这个场景太常见了，于是我经常在我的项目中通过一个辅助类来做此类检查。这个类用来检查方法参数，所以命名为 Guard，主要代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Guard</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NotNull</span>(<span class="params"><span class="built_in">object</span> param, <span class="built_in">string</span> paramName</span>)</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (param <span class="keyword">is</span> <span class="literal">null</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(paramName);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NotNullOrEmpty</span>(<span class="params"><span class="built_in">string</span> param, <span class="built_in">string</span> paramName</span>)</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        NotNull(param, paramName);  </span><br><span class="line">        <span class="keyword">if</span> (param == <span class="built_in">string</span>.Empty)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">$&quot;The string can not be empty.&quot;</span>, paramName);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> NotNullOrEmpty&amp;lt;T&amp;gt;(IEnumerable&amp;lt;T&amp;gt; param, <span class="built_in">string</span> paramName)  </span><br><span class="line">    &#123;  </span><br><span class="line">        NotNull(param, paramName);  </span><br><span class="line">        <span class="keyword">if</span> (param.Count() == <span class="number">0</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;The collection can not be empty.&quot;</span>, paramName);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类包含了三个常见的非空检查，包括 null、空字符串、空集合的检查。使用示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">HashPassword</span>(<span class="params"><span class="built_in">string</span> password</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    Guard.NotNull(password, <span class="keyword">nameof</span>(password));  </span><br><span class="line">    ...  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&amp;lt;TSource&amp;gt; DistinctBy&amp;lt;TSource, TKey&amp;gt;(  </span><br><span class="line">    <span class="keyword">this</span> IEnumerable&amp;lt;TSource&amp;gt; source,  </span><br><span class="line">    Func&amp;lt;TSource, TKey&amp;gt; keySelector)  </span><br><span class="line">&#123;  </span><br><span class="line">    Guard.NotNullOrEmpty(source, <span class="keyword">nameof</span>(source));  </span><br><span class="line">    ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>介于这种非空检查极其常见，C# 9.0 对此做了简化，增加了操作符‘!’，放在参数名后面，表示此参数不接受 null 值。使用方式如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">HashPassword</span>(<span class="params"><span class="built_in">string</span> password!</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简化了很多有木有。这个提案已经纳入 C# 9.0 的特性中，但目前（2020-06-13）还没有完成开发。</p>
<p>这个特性只支持非 null 检查，其它参数检查场景还是不够用的，我还是会通过辅助类来进行像空字符串、空集合的检查。</p>
<p>这个特性在写公共类库的时候很有用，但我想大多数人在写业务逻辑代码的时候可能用不到这个特性，一般会封自己的参数检查机制。比如，我在项目中，对于上层 API 开发，我通过封装一个辅助类（ApiGuard）来对对参数进行检查，如果参数不通过，则抛出相应的业务异常，而不是 ArgumentNullException。比如下面的一段截取自我的 GeekGist 小项目的代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ApiGuard</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EnsureNotNull</span>(<span class="params"><span class="built_in">object</span> param, <span class="built_in">string</span> paramName</span>)</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (param == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> BadRequestException(<span class="string">$&quot;<span class="subst">&#123;paramName&#125;</span> can not be null.&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> EnsureNotEmpty&amp;lt;T&amp;gt;(IEnumerable&amp;lt;T&amp;gt; collection, <span class="built_in">string</span> paramName)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (collection == <span class="literal">null</span> || collection.Count() == <span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BadRequestException(<span class="string">$&quot;<span class="subst">&#123;paramName&#125;</span> can not be null or empty.&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EnsureExist</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, <span class="built_in">string</span> message = <span class="string">&quot;Not found&quot;</span></span>)</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> BadRequestException(message);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EnsureNotExist</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, <span class="built_in">string</span> message = <span class="string">&quot;Already existed&quot;</span></span>)</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> != <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> BadRequestException(message);  </span><br><span class="line">    &#125;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">UpdateAsync</span>(<span class="params"><span class="built_in">long</span> id, BookUpdateDto dto</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    ApiGuard.EnsureNotNull(dto, <span class="keyword">nameof</span>(dto));  </span><br><span class="line">    ApiGuard.EnsureNotEmpty(dto.TagValues, <span class="keyword">nameof</span>(dto.TagValues));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> book = <span class="keyword">await</span> DbSet  </span><br><span class="line">        .Include(x =&gt; x.BookTags)  </span><br><span class="line">        .FirstOrDefaultAsync(x =&gt; x.Id == id);  </span><br><span class="line">    ApiGuard.EnsureExist(book);  </span><br><span class="line">  </span><br><span class="line">    Mapper.Map(dto, book);  </span><br><span class="line">  </span><br><span class="line">    ...  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ApiGuard 的好处是，当 API 接口接到不合要求的参数时，可以自定义响应返回内容。比如，增加一个 Filter 或中间件用来全局捕获业务代码异常，根据不同的异常返回给前端不同的状态码和消息提示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Task <span class="title">HandleExceptionAsync</span>(<span class="params">HttpContext context, Exception exception</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    ApiResult result;  </span><br><span class="line">    <span class="keyword">if</span> (exception <span class="keyword">is</span> BadRequestException)  </span><br><span class="line">    &#123;  </span><br><span class="line">        result = ApiResult.Error(exception.Message, <span class="number">400</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">is</span> NotFoundException)  </span><br><span class="line">    &#123;  </span><br><span class="line">        message = <span class="built_in">string</span>.IsNullOrEmpty(message) ? <span class="string">&quot;Not Found&quot;</span> : message;  </span><br><span class="line">        result = ApiResult.Error(message, <span class="number">404</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">is</span> UnauthorizedAccessException)  </span><br><span class="line">    &#123;  </span><br><span class="line">        message = <span class="built_in">string</span>.IsNullOrEmpty(message) ? <span class="string">&quot;Unauthorized&quot;</span> : message;  </span><br><span class="line">        result = ApiResult.Error(message, <span class="number">401</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只是一个参数非空检查，在实际开发中却有不少的学问，所以学好了理论还要多实践才能更透彻的理解它。</p>
<h2 id="目标类型推导-new-表达式"><a href="#目标类型推导-new-表达式" class="headerlink" title="目标类型推导 new 表达式"></a>目标类型推导 new 表达式</h2><p>关于类型推导想必大家都很熟悉，它是在 var 关键字引入的时候引入 C# 的。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">10</span>;  </span><br><span class="line"><span class="keyword">var</span> u = <span class="keyword">new</span> User();</span><br></pre></td></tr></table></figure>

<p>编译器会通过右边的字面量自动推导左边变量的类型，这种推导方式可以归纳为：从上下文右边推导出左边的类型。我们不防把它称为源类型推导（Source-typed inferring，参考 Target-typed 自创的术语）。</p>
<p>相应的，有源类型推导就有目标类型推导 (Target-typed inferring)，它是指从上下文左边推导出右边的类型。比如数组的初始化和 Lambda 表达式常常是目标类型推导的表达式。举个例子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有使用类型推导  </span></span><br><span class="line"><span class="built_in">string</span>\[\] s = <span class="keyword">new</span> <span class="built_in">string</span>\[\] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span> &#125;;  </span><br><span class="line"><span class="comment">// 目标类型推导（左推右）  </span></span><br><span class="line"><span class="built_in">string</span>\[\] s = <span class="keyword">new</span> &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span> &#125;;  </span><br><span class="line"><span class="built_in">string</span>\[\] s = <span class="keyword">new</span> \[\] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span> &#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 没有使用类型推导  </span></span><br><span class="line">Users.FirstOrDefault&amp;lt;User&amp;gt;(u =&gt; u.id = <span class="number">123</span>);  </span><br><span class="line"><span class="comment">// 目标类型推导（左推右）  </span></span><br><span class="line">Users.FirstOrDefault(u =&gt; u.id = <span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<p>这次在 C# 9 中，增加了用户定义类型 new 表达式的目标类型推导，即通过上下文左边自动推导 new 表达式的类型，从而在使用 new 构造时省略类型的指定，请看示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C# 9 之前  </span></span><br><span class="line">Point p = <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">5</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// C# 9  </span></span><br><span class="line">Point p = <span class="keyword">new</span> (<span class="number">3</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>除此之外，C# 9 也增加了操作符 <code>??</code> 和 <code>?:</code> 的目标类型推导支持。之前这两个操作符必须要求两边的操作对象都是相同的类型，否则会编译报错。而在 C# 9 中，只要目标类型是操作对象共同的基类就不再会编译报错了，比如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student 和 Customer 拥有共同的父类 Person  </span></span><br><span class="line">Person person = (Person)(student ?? customer); <span class="comment">// C# 9 之前  </span></span><br><span class="line">Person person = student ?? customer; <span class="comment">// C# 9  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 可空类型，0 和 null 都可以隐式转换为 int? 类型  </span></span><br><span class="line"><span class="built_in">int</span>? result = b ? <span class="number">0</span> : (<span class="built_in">int</span>?)<span class="literal">null</span>; <span class="comment">// C# 9 之前  </span></span><br><span class="line"><span class="built_in">int</span>? result = b ? <span class="number">0</span> : <span class="literal">null</span>; <span class="comment">// C# 9</span></span><br></pre></td></tr></table></figure>
<p>其实本文的核心就一句代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point p = <span class="keyword">new</span> (<span class="number">3</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h2 id="只读属性和记录"><a href="#只读属性和记录" class="headerlink" title="只读属性和记录"></a>只读属性和记录</h2><p>熟悉函数式编程的童鞋一定对“只读”这个词不陌生。为了保证代码块自身的“纯洁”，函数式编程是不能随便“弄脏”外来事物（参数、变量等）的，所以“只读”对函数式编程非常重要。</p>
<p>为了丰富 C# 对函数式编程支持，较新的 C# 版本引入了一些很有用的新特性。比如 C# 8 中就对 struct 类型的方法增加了 readonly 修饰符支持，被 readonly 修饰的方法是不能修改该方法所在类的属性的。举个例子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> FooValue  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> A &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="built_in">int</span> <span class="title">IncreaseA</span>()</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        A = A + <span class="number">1</span>; <span class="comment">// 报错  </span></span><br><span class="line">        <span class="keyword">return</span> A;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 C# 9 又进一步增加了对“只读”的支持，此次增加了 init-only 属性和 record 相关特性，下面一一介绍。</p>
<h3 id="Init-only-属性"><a href="#Init-only-属性" class="headerlink" title="Init-only 属性"></a>Init-only 属性</h3><p>我们知道类的属性有 set 和 get 两种访问器，现在 C# 9 增加一种属性访问器：init。init 是 set 访问器的变体，它的作用是使属性只能在对象初始化的时候对其赋值，之后该属性就是只读的，因此叫 init-only 属性。使用方式如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> PropA &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> PropB &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>赋值操作：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo &#123;  PropA = <span class="string">&quot;A&quot;</span>, PropB = <span class="string">&quot;B&quot;</span> &#125;;  </span><br><span class="line">foo.PropA = <span class="string">&quot;AA&quot;</span>; <span class="comment">// 报错，PropA 此时是只读的！</span></span><br></pre></td></tr></table></figure>

<p>由于 init 是在初始化阶段赋值，所以它可以在类内部修改 readonly 修饰的字段。比如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> propA;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> propB;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> PropA  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">get</span> =\&gt; propA;  </span><br><span class="line">        <span class="keyword">init</span> =&gt; propA = (<span class="keyword">value</span> ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(propA)));  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> PropA  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">get</span> =\&gt; propB;  </span><br><span class="line">        <span class="keyword">init</span> =&gt; propB = (<span class="keyword">value</span> ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(propB)));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你知道在构造函数中可以对只读字段&#x2F;属性赋值就自然也理解这一点。</p>
<h3 id="记录-Record"><a href="#记录-Record" class="headerlink" title="记录 (Record)"></a>记录 (Record)</h3><p>做过财务系统的人都知道交易记录一旦入账是不能修改的，如果录入错误，就要新录入一笔负的记录把之前的红冲掉，再录入正确的记录。应对类似这种只读记录的场景，C# 9 引入了 Record（记录，下文均使用中文的“记录”）的概念，它用来支持整个对象的只读特性（即实例化后为只读）。使用方式如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> data <span class="keyword">class</span> <span class="title">Foo</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> PropA &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> PropB &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用了一个 data 关键字，表示该类的对象只是纯粹的记录值，它不是可修改的状态（在函数式编程中，所有的数据修改都是状态在发生变化）。</p>
<p>上面的太麻烦了，可以这样简写：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> data <span class="keyword">class</span> <span class="title">Foo</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">string</span> PropA;  </span><br><span class="line">    <span class="built_in">string</span> PropB;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>默认属性都是 public 的，如果实在要改为 private，可以在属性定义前面加上 private 修饰符。</p>
<h3 id="定位记录-Positional-Record"><a href="#定位记录-Positional-Record" class="headerlink" title="定位记录 (Positional Record)"></a>定位记录 (Positional Record)</h3><p>有时候为了初始化更方便，可以定义构造函数来给属性赋值，初始化时只需要把属性值按顺序传给构造函数即可，这个操作称为定位构造(Positional Construction)。同样，也可以使用解构函数(Deconstructor)来实现属性的解构，即按照解构函数的参数顺序从对象中提取属性的值，被称为定位解构(Positional Deconstructor)。实现了定位构造或定位解构的记录称为定位记录(Positional Record)。下面是一个定位记录的实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> data <span class="keyword">class</span> <span class="title">Foo</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">string</span> PropA;  </span><br><span class="line">    <span class="built_in">string</span> PropB;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">string</span> propA, <span class="built_in">string</span> propB</span>)</span>  </span><br><span class="line">      =\&gt; (PropA, PropB) = (propA, propB);  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Deconstruct</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">string</span> propA, <span class="keyword">out</span> <span class="built_in">string</span> propB</span>)</span>  </span><br><span class="line">      =\&gt;  (propA, propB) = (PropA, PropB);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个写法太麻烦了，可以直接简写为：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> data <span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">string</span> PropA, <span class="built_in">string</span> PropB</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这样简短一句代码，其内部默认实现了 init-only 自动属性，且同时为所有属性定义了构造函数和解构函数。</p>
<p>使用示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>);  <span class="comment">// 构造定位  </span></span><br><span class="line"><span class="keyword">var</span> (a, b) = foo;               <span class="comment">// 解构定位</span></span><br></pre></td></tr></table></figure>

<p>可以想象，记录的大部分使用场景，以上简写的写法能满足需求。若有特殊场景，就不能简单，需要进行自定义修改其默认行为。</p>
<h3 id="with-表达式"><a href="#with-表达式" class="headerlink" title="with 表达式"></a>with 表达式</h3><p>当处理不可变数据时，若要生成不同的状态，一个常见的场景是在一条旧记录基础上拷贝一条新的记录。比如我们要修改 Foo 对象的 PropA 属性，我们就要拷贝该对象生成一个新的对象。这个操作在函数式编程中被称为“非破坏性修改 (non-destructive mutation)”。为了支持记录的这个操作，C# 9 引入了 with 表达式，它可以很方便在一条原有记录基础上创建一条新记录。示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> other = foo <span class="keyword">with</span> &#123; PropA = <span class="string">&quot;AA&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>with 表达式内部其实是通过一个默认的 protected 构造函数来实现的，大致如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Foo</span>(<span class="params">Foo original</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// 拷贝 original 的所有字段  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果默认实现的字段拷贝不符合你的需求，你也可以手动实现这个构造函数。</p>
<h2 id="Lambda-弃元参数"><a href="#Lambda-弃元参数" class="headerlink" title="Lambda 弃元参数"></a>Lambda 弃元参数</h2><p>弃元（Discards） 是在 C# 7.0 的时候开始支持的，它是一种人为丢弃不使用的临时虚拟变量。语法上它是用来赋值的，但它却不被分配存储空间，即没有值，所以不能从中读取值。弃元用 _ (下划线) 表示，下划线是一个关键字，只能赋值，不能读取，例如：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/TIcgLjdQYUzBRouMkabxbAIxviaU8YL9RDwtpVicfY8ybS3bTTeEeuMVNhLhF7ibfIVRKOHnZFlicUiaqHyOnKRAVgg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在 C# 7.0 中，弃元的使用场景主要有下面四种：</p>
<ul>
<li><p>元组和对象的解构</p>
</li>
<li><p>使用 is 和 switch 的模式匹配</p>
</li>
<li><p>对具有 out 参数的方法的调用</p>
</li>
<li><p>作用域内独立使用场景</p>
</li>
</ul>
<p>针对这几个场景，用下面的几段代码演示一下。</p>
<p>场景一：元组&#x2F;对象的解构</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line">(_, _, _, _, <span class="keyword">var</span> fifth) = tuple;</span><br></pre></td></tr></table></figure>

<p>场景二：使用 is&#x2F;switch 的模式匹配</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = CultureInfo.CurrentCulture.DateTimeFormat;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">switch</span> (obj)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">case</span> IFormatProvider fmt:  </span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;fmt&#125;</span> object&quot;</span>);  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    <span class="keyword">case</span> <span class="literal">null</span>:  </span><br><span class="line">        Console.Write(<span class="string">&quot;A null object reference&quot;</span>);  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">object</span> _:  </span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Some object type without format information&quot;</span>);  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">is</span> <span class="built_in">object</span> _)  </span><br><span class="line">&#123;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>场景三：对具有 out 参数的方法的调用</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">10</span>);  </span><br><span class="line"><span class="comment">// 只要 x, 不关心 y  </span></span><br><span class="line">point.GetCoordinates(<span class="keyword">out</span> <span class="built_in">int</span> x, <span class="keyword">out</span> _);</span><br></pre></td></tr></table></figure>

<p>场景四：作用域内独立使用场景</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span>(<span class="params">Dto dto</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    _ = dto ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(dto));  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>理解了弃元，也了解了弃元的四种使用场景，那么对下面这个 C# 9.0 新支持的弃元使用场景就容易理解了。</p>
<p>C# 9.0 对弃元增加了一种场景支持：Lambda 参数，也包括匿名方法参数。示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C# 9 之前  </span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>\&gt; zero = (a, b) =&gt; <span class="number">0</span>;  </span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>\&gt; func = <span class="built_in">delegate</span> (<span class="built_in">int</span> a, <span class="built_in">int</span> b) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// C# 9  </span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>\&gt; zero = (_, _) =&gt; <span class="number">0</span>;  </span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>\&gt; func = <span class="built_in">delegate</span> (<span class="built_in">int</span> _, <span class="built_in">int</span> _) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;;</span><br></pre></td></tr></table></figure>

<p>在 C# 9 之前，即便不使用的 Lambda 参数也需要给它命名。C# 9 支持弃元参数一方面简化了命名，另一方面也节省了内存分配。更重要的是它使得编程的意图更明确，让人一看就知道这个参数是不用的，增强了代码的可读性和可维护性。</p>
<h2 id="使用新语法提升-if-语句美感"><a href="#使用新语法提升-if-语句美感" class="headerlink" title="使用新语法提升 if 语句美感"></a>使用新语法提升 if 语句美感</h2><p>C# 语言一贯秉承简洁优美的宗旨，每次升级都会带来一些语法糖，让我们可以使代码变得更简洁。本文分享两个使用 C# 9.0 提升 <code>if</code> 语句美感的技巧示例。</p>
<h3 id="使用属性模式代替-IsNullOrEmpty"><a href="#使用属性模式代替-IsNullOrEmpty" class="headerlink" title="使用属性模式代替 IsNullOrEmpty"></a>使用属性模式代替 IsNullOrEmpty</h3><p>在任何你使用 <code>IsNullOrEmpty</code> 的时候，可以考虑这样替换：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>? hello = <span class="string">&quot;hello world&quot;</span>;  </span><br><span class="line">hello = <span class="literal">null</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 旧的方式  </span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(hello))  </span><br><span class="line">&#123;  </span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;hello&#125;</span> has <span class="subst">&#123;hello.Length&#125;</span> letters.&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 新的方式  </span></span><br><span class="line"><span class="keyword">if</span> (hello <span class="keyword">is</span> &#123; Length: &gt;<span class="number">0</span> &#125;)  </span><br><span class="line">&#123;  </span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;hello&#125;</span> has <span class="subst">&#123;hello.Length&#125;</span> letters.&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性模式相当灵活，你还可以把它用在数组上，对数组进行各种判断。比如判断可空字符串数组中的字符串元素是否为空或空白：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>?\[\]? greetings = <span class="keyword">new</span> <span class="built_in">string</span>\[<span class="number">2</span>\];  </span><br><span class="line">greetings\[<span class="number">0</span>\] = <span class="string">&quot;Hello world&quot;</span>;  </span><br><span class="line">greetings = <span class="literal">null</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 旧的方式  </span></span><br><span class="line"><span class="keyword">if</span> (greetings != <span class="literal">null</span> &amp;&amp; !<span class="built_in">string</span>.IsNullOrEmpty(greetings\[<span class="number">0</span>\]))  </span><br><span class="line">&#123;  </span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;greetings\[<span class="number">0</span>\]&#125;</span> has <span class="subst">&#123;greetings\[<span class="number">0</span>\].Length&#125;</span> letters.&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 新的方式  </span></span><br><span class="line"><span class="keyword">if</span> (greetings?\[<span class="number">0</span>\] <span class="keyword">is</span> &#123;Length: &gt; <span class="number">0</span>&#125; hi)  </span><br><span class="line">&#123;  </span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;hi&#125;</span> has <span class="subst">&#123;hi.Length&#125;</span> letters.&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚开始你可能会觉得阅读体验不太好，但用多了看多了，这种简洁的方法更有利于阅读。</p>
<h3 id="使用逻辑模式简化多重判断"><a href="#使用逻辑模式简化多重判断" class="headerlink" title="使用逻辑模式简化多重判断"></a>使用逻辑模式简化多重判断</h3><p>对于同一个值，把它与其它多个值进行比较判断，可以用 <code>or</code> 、<code>and </code>逻辑模式简化，示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ConsoleKeyInfo userInput = Console.ReadKey();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 旧的方式  </span></span><br><span class="line"><span class="keyword">if</span> (userInput.KeyChar == <span class="string">&#x27;Y&#x27;</span> || userInput.KeyChar == <span class="string">&#x27;y&#x27;</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Do something.&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 新的方式  </span></span><br><span class="line"><span class="keyword">if</span> (userInput.KeyChar <span class="keyword">is</span> <span class="string">&#x27;Y&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;y&#x27;</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Do something.&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前很多人不解 C# 9.0 为什么要引入 <code>or</code> 、<code>and</code> 逻辑关键字，通过这个示例就一目了然了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.zzonn.com/2020/11/01/C#%209.0%20%E6%96%B0%E7%89%B9%E6%80%A7-c90%E6%96%B0%E7%89%B9%E6%80%A7/" data-id="clf0jcv6n00056ocx575d4sff" data-title="C# 9.0 新特性" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/net/" rel="tag">.net</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C#</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Vue项目中使用Typescript-vue-xiang-mu-zhong-shi-yong-typescript" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/24/Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Typescript-vue-xiang-mu-zhong-shi-yong-typescript/" class="article-date">
  <time class="dt-published" datetime="2020-05-24T04:48:17.000Z" itemprop="datePublished">2020-05-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/24/Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Typescript-vue-xiang-mu-zhong-shi-yong-typescript/">Vue项目中使用Typescript</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>基础<a target="_blank" rel="noopener" href="https://typescript.bootcss.com/">api官方文档</a></p>
</blockquote>
<p>简单来说，ts属于强类型语言，它的优势在于静态类型检查，概括来说主要包括以下几点：</p>
<ul>
<li>静态类型检查</li>
<li>IDE 智能提示</li>
<li>代码重构</li>
<li>可读性</li>
</ul>
<h2 id="typescript在vue项目中的基础用法"><a href="#typescript在vue项目中的基础用法" class="headerlink" title="typescript在vue项目中的基础用法"></a>typescript在vue项目中的基础用法</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/kaorun343/vue-property-decorator">vue-property-decorator</a></p>
</blockquote>
<p><code>vue-property-decorator</code>在<code>vue-class-component</code>的基础上增加了更多与<code>Vue</code>相关的装饰器，使<code>Vue</code>组件更好的跟TS结合使用。这两者都是离不开装饰器的，（decorator）装饰器已在ES提案中。<code>Decorator</code>是装饰器模式的实践。装饰器模式呢，它是继承关系的一个替代方案。动态地给对象添加额外的职责。在不改变接口的前提下，增强类的性能。</p>
<p><code>vue-property-decorator</code>是这个Vue项目文件中完全依赖的库，它是Vue官方推荐的并且依赖于<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-class-component">vue-class-component</a>，先介绍下它在项目中的常见用法。</p>
<ul>
<li><a href="/Component">@Component </a></li>
<li><a href="/Emit">@Emit </a></li>
<li><a href="/Provice">@Provice </a> <a href="/Inject">@Inject </a></li>
<li><a href="/Prop">@Prop </a></li>
<li><a href="/Watch">@Watch </a></li>
<li><a href="/Model">@Model </a></li>
<li><a href="/Minxins">@Minxins </a></li>
</ul>
<h3 id="Component-类装饰器"><a href="#Component-类装饰器" class="headerlink" title="@Component  类装饰器"></a><a href="/Component">@Component </a> 类装饰器</h3><p>首先，Vue页面中的script部分要加一个lang&#x3D;ts，这样安装好typescript正能引用</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">import</span> &#123;<span class="title class_">Vue</span>, <span class="title class_">Component</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span>;</span><br><span class="line">    <span class="keyword">import</span> <span class="title class_">BaseHeader</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/BaseHeader&#x27;</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公共头部组件</span></span><br><span class="line">    <span class="meta">@Component</span>(&#123;</span><br><span class="line">        <span class="attr">components</span>: &#123;</span><br><span class="line">            <span class="title class_">BaseHeader</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="attr">stateA</span>:<span class="built_in">boolean</span> = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">private</span> <span class="attr">stateB</span>:<span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="attr">stateC</span>:<span class="built_in">number</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="attr">stateD</span>:<span class="built_in">any</span> = &#123;&#125;</span><br><span class="line">        <span class="attr">stateE</span>:<span class="built_in">any</span>[] = []</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<p>等同于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line">    <span class="keyword">import</span> <span class="title class_">BaseHeader</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/BaseHeader&#x27;</span>; <span class="comment">//公共头部组件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        <span class="attr">components</span>: &#123;</span><br><span class="line">            <span class="title class_">BaseHeader</span></span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">stateA</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">stateB</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                <span class="attr">stateC</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">stateD</span>: &#123;&#125;,</span><br><span class="line">                <span class="attr">stateE</span>: []</span><br><span class="line">            &#125;	</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<p><code>vue-property-decorator</code>在项目中的应用最主要是起一个装饰器的作用，差异化的话看对比就非常直观了</p>
<p>data变量的定义比较多元化，这里区别有加private，不加就是public，当变量标记为private时，它就不能在声明它的类的外部访问。</p>
<p><code>@Component</code>装饰器属性名必须得写上</p>
<hr>
<h3 id="Prop"><a href="#Prop" class="headerlink" title="@Prop "></a><a href="/Prop">@Prop </a></h3><p>父子组件之间的属性传值</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">    <span class="meta">@Prop</span>(&#123; <span class="attr">default</span>: <span class="number">0</span> &#125;) <span class="keyword">private</span> propA!: <span class="built_in">number</span></span><br><span class="line">    <span class="meta">@Prop</span>(&#123; <span class="attr">default</span>: <span class="function">() =&gt;</span> [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">50</span>] &#125;) <span class="keyword">private</span> propB!: <span class="built_in">number</span>[]</span><br><span class="line">    <span class="meta">@Prop</span>(&#123; <span class="attr">default</span>: <span class="string">&#x27;total, sizes, prev, pager, next, jumper&#x27;</span> &#125;) <span class="keyword">private</span> propC!: <span class="built_in">string</span></span><br><span class="line">    <span class="meta">@Prop</span>(&#123; <span class="attr">default</span>: <span class="literal">true</span> &#125;) <span class="keyword">private</span> propD!: <span class="built_in">boolean</span>,</span><br><span class="line">    <span class="meta">@prop</span>([<span class="title class_">String</span>, <span class="title class_">Boolean</span>]) <span class="attr">propE</span>: <span class="built_in">string</span> | <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>等同于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">propA</span>: &#123;</span><br><span class="line">	    <span class="attr">type</span>: <span class="title class_">Number</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">propB</span>: &#123;</span><br><span class="line">    	<span class="attr">type</span>: <span class="title class_">Array</span>,</span><br><span class="line">    	<span class="attr">default</span>: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">50</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">propC</span>: &#123;</span><br><span class="line">    	<span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    	<span class="attr">default</span>: <span class="string">&#x27;total, sizes, prev, pager, next, jumper&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">propD</span>: &#123;</span><br><span class="line">    	<span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    	<span class="attr">default</span>: <span class="string">&#x27;total, sizes, prev, pager, next, jumper&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">propE</span>: &#123;</span><br><span class="line">    	<span class="attr">type</span>: [<span class="title class_">String</span>, <span class="title class_">Boolean</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里有两个常用修饰符<code>!</code> <code>?</code>，<code>!</code>和可选参数<code>?</code>是相对的, <code>!</code>表示强制解析（也就是告诉typescript编译器，我这里一定有值），你写<code>?</code>的时候再调用，<code>typescript</code>会提示可能为<code>undefined</code></p>
<hr>
<h3 id="Emit"><a href="#Emit" class="headerlink" title="@Emit "></a><a href="/Emit">@Emit </a></h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">YourComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Emit</span>(<span class="string">&#x27;reset&#x27;</span>)</span><br><span class="line">  <span class="title function_">resetCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Emit</span>()</span><br><span class="line">  <span class="title function_">returnValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Emit</span>()</span><br><span class="line">  <span class="title function_">onInputChange</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> e.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>等同于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">resetCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span></span><br><span class="line">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;reset&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">returnValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;return-value&#x27;</span>, <span class="number">10</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">onInputChange</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;on-input-change&#x27;</span>, e.<span class="property">target</span>.<span class="property">value</span>, e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>@Emit装饰器</code>的函数会在运行之后触发等同于其函数名<code>(驼峰式会转为横杠式写法)</code>的事件, 并将其函数传递给<code>$emit</code></p>
<p>@Emit触发事件有两种写法</p>
<ul>
<li>@Emit()不传参数,那么它触发的事件名就是它所修饰的函数名.</li>
<li>@Emit(name: string),里面传递一个字符串,该字符串为要触发的事件名</li>
</ul>
<hr>
<h3 id="Watch-观察属性装饰器"><a href="#Watch-观察属性装饰器" class="headerlink" title="@Watch  观察属性装饰器"></a><a href="/Watch">@Watch </a> 观察属性装饰器</h3><p>@Watch装饰器主要用于替代<code>Vue</code>属性中的<code>watch</code>属性，监听依赖的变量值变化而做一系列的操作</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">YourComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  <span class="meta">@Watch</span>(<span class="string">&#x27;child&#x27;</span>)</span><br><span class="line">  <span class="title function_">onChildChanged</span>(<span class="params">val: <span class="built_in">string</span>, oldVal: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Watch</span>(<span class="string">&#x27;person&#x27;</span>, &#123; <span class="attr">immediate</span>: <span class="literal">true</span>, <span class="attr">deep</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  <span class="title function_">onPersonChanged</span>(<span class="params">val: Person, oldVal: Person</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>等同于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">	<span class="title function_">child</span>(<span class="params">val, oldVal</span>) &#123;&#125;,</span><br><span class="line">	<span class="attr">person</span>: &#123;</span><br><span class="line">		<span class="title function_">handler</span>(<span class="params">val, oldVal</span>) &#123;&#125;,</span><br><span class="line">		<span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="attr">deep</span>: <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>watch 是一个对象，对象就有键，有值。</p>
<ul>
<li>第一个handler：其值是一个回调函数。即监听到变化时应该执行的函数。</li>
<li>第二个是deep：其值是true或false；确认是否深入监听。deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器（受现代 JavaScript 的限制 (以及废弃 Object.observe)，Vue 不能检测到对象属性的添加或删除）</li>
<li>第三个是immediate：其值是true或false；immediate:true代表如果在 wacth 里声明了之后，就会立即先去执行里面的handler方法，如果为 false就跟我们以前的效果一样，不会在绑定的时候就执行</li>
</ul>
<p><code>@Watch</code>使用非常简单,接受第一个参数为要监听的属性名, 第二个属性为可选对象。@Watch所装饰的函数即监听到属性变化之后应该执行的函数。</p>
<p><code>@Watch</code>装饰的函数的函数名并非如上<code>onStateChanged</code>严格命名，它是多元化的，你可以随心所欲的命名，当然，能按照规范化的命名会使你的代码阅读性更好。</p>
<hr>
<h3 id="Minxins"><a href="#Minxins" class="headerlink" title="@Minxins "></a><a href="/Minxins">@Minxins </a></h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myMixin.ts</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">MyMixin</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  <span class="attr">mixinValue</span>:<span class="built_in">string</span> = <span class="string">&#x27;Hello World!!!&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用mixins</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MyMixin</span> <span class="keyword">from</span> <span class="string">&#x27;./myMixin.js&#x27;</span></span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title function_">mixins</span>(<span class="params">MyMixin</span>) &#123;</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">mixinValue</span>) <span class="comment">// -&gt; Hello World!!!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>另外一种mixins写法</p>
<p>先改造一下<code>myMixin.ts</code>,定义<code>vue/type/vue</code>模块,实现<code>Vue接口</code></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myMixin.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Vue</span>, <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;vue/types/vue&#x27;</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">        <span class="attr">mixinValue</span>: <span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">myMixins</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">    <span class="attr">mixinValue</span>: <span class="built_in">string</span> = <span class="string">&#x27;Hello World!!!&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>引用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Vue</span>, <span class="title class_">Component</span>, <span class="title class_">Prop</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MyMixin</span> <span class="keyword">from</span> <span class="string">&#x27;./myMixin.js&#x27;</span></span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span>(&#123;</span><br><span class="line">    <span class="attr">mixins</span>: [<span class="title class_">MyMixin</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Vue</span>&#123;</span><br><span class="line">    <span class="title function_">created</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(mixinValue) <span class="comment">// =&gt; Hello World!!!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>两种方式不同在于定义<code>mixins</code>时如果没有定义<code>vue/type/vue</code>模块, 那么在混入的时候就要继承该<code>mixins</code>; 如果定义<code>vue/type/vue</code>模块,在混入时可以在<code>@Component</code>中<code>mixins</code>直接混入。</p>
<hr>
<h3 id="Model"><a href="#Model" class="headerlink" title="@Model "></a><a href="/Model">@Model </a></h3><p><code>@Model装饰器</code>允许我们在一个组件上自定义<code>v-model</code>，接收两个参数：</p>
<ul>
<li>event: string 事件名。</li>
<li>options: Constructor | Constructor[] | PropOptions 与@Prop的第一个参数一致。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Vue</span>, <span class="title class_">Component</span>, <span class="title class_">Model</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">MyInput</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  <span class="meta">@Model</span>(<span class="string">&#x27;change&#x27;</span>, &#123; <span class="attr">type</span>: <span class="title class_">String</span>, <span class="attr">default</span>: <span class="string">&#x27;Hello world!!!&#x27;</span> &#125;) <span class="keyword">readonly</span> value!: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>等同于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">:value</span>=<span class="string">&quot;value&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    @<span class="attr">change</span>=<span class="string">&quot;$emit(&#x27;change&#x27;, $event.target.value)&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  /&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">model</span>: &#123;</span><br><span class="line">    <span class="attr">prop</span>: <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">    <span class="attr">event</span>: <span class="string">&#x27;change&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="string">&#x27;Hello world!!!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Provide-Inject"><a href="#Provide-Inject" class="headerlink" title="@Provide  @Inject "></a><a href="/Provide">@Provide </a> <a href="/Inject">@Inject </a></h3><p><code>@Provide</code> 声明一个值 , 在其他地方用 <code>@Inject</code> 接收，在实战项目中用得不多，一般用于不依赖于任何第三方状态管理库（如vuex）的组件编写</p>
<hr>
<h3 id="Ref-refKey-string"><a href="#Ref-refKey-string" class="headerlink" title="@Ref(refKey?: string)"></a>@Ref(refKey?: string)</h3><p><code>@Ref</code>装饰器接收一个可选参数，用来指向元素或子组件的引用信息。如果没有提供这个参数，会使用装饰器后面的属性名充当参数</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Vue</span>, <span class="title class_">Component</span>, <span class="title class_">Ref</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Form</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Componentexport</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  <span class="meta">@Ref</span>() <span class="keyword">readonly</span> loginForm!: <span class="title class_">Form</span></span><br><span class="line">  <span class="meta">@Ref</span>(<span class="string">&#x27;changePasswordForm&#x27;</span>) <span class="keyword">readonly</span> passwordForm!: <span class="title class_">Form</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">handleLogin</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">loginForm</span>.<span class="title function_">validate</span>(<span class="function"><span class="params">valide</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (valide) &#123;</span><br><span class="line">        <span class="comment">// login...</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// error tips</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>等同于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="attr">loginForm</span>: &#123;</span><br><span class="line">      <span class="attr">cache</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">loginForm</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">passwordForm</span>: &#123;</span><br><span class="line">      <span class="attr">cache</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">changePasswordForm</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>使用时切记要引入修饰器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">	<span class="title class_">Vue</span>,</span><br><span class="line">	<span class="title class_">Component</span>,</span><br><span class="line">	<span class="title class_">Prop</span>,</span><br><span class="line">	<span class="title class_">Component</span>,</span><br><span class="line">	<span class="title class_">Emit</span>,</span><br><span class="line">	<span class="title class_">Provice</span>,</span><br><span class="line">	<span class="title class_">Inject</span>,</span><br><span class="line">	<span class="title class_">Watch</span>,</span><br><span class="line">	<span class="title class_">Model</span>,</span><br><span class="line">	<span class="title class_">Minxins</span>,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><p>以下的<code>public、private</code>在引入tslint后是必写的，否则会有警告，如果没有引的话是可以不写的</p>
<table>
<thead>
<tr>
<th align="left">Ts</th>
<th align="center">Js</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">public created() {}</td>
<td align="center">created() {}</td>
<td align="right">初始化</td>
</tr>
<tr>
<td align="left">public mounted() {}</td>
<td align="center">mounted() {}</td>
<td align="right">挂载完毕</td>
</tr>
<tr>
<td align="left">private _getInitData() {}</td>
<td align="center">methods: { _getInitData() {} }</td>
<td align="right">方法</td>
</tr>
<tr>
<td align="left">private get _userName() {}</td>
<td align="center">computed: { _userName() {} }</td>
<td align="right">计算属性</td>
</tr>
<tr>
<td align="left">public destroyed() {}</td>
<td align="center">destroyed() {}</td>
<td align="right">销毁生命周期</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.zzonn.com/2020/05/24/Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Typescript-vue-xiang-mu-zhong-shi-yong-typescript/" data-id="clf0jcv72001d6ocx4m2wglp9" data-title="Vue项目中使用Typescript" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-C#.NET问答 高级进阶篇-cnet-wen-da-gao-ji-jin-jie-pian" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/20/C#.NET%E9%97%AE%E7%AD%94%20%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6%E7%AF%87-cnet-wen-da-gao-ji-jin-jie-pian/" class="article-date">
  <time class="dt-published" datetime="2020-05-20T14:05:35.000Z" itemprop="datePublished">2020-05-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Net/">.Net</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/20/C#.NET%E9%97%AE%E7%AD%94%20%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6%E7%AF%87-cnet-wen-da-gao-ji-jin-jie-pian/">C#.NET问答 高级进阶篇</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-说说什么是架构模式。"><a href="#1-说说什么是架构模式。" class="headerlink" title="1.说说什么是架构模式。"></a>1.说说什么是架构模式。</h2><p>1，分层。<br>2，分割。<br>分层是对网站进行横向的切分，那么分割就是对网站进行纵向的切分。将网站按照不同业务分割成小应<br>用，可以有效控制网站的复杂程度。<br>3，分布式。<br>在大型网站中，分层和分割后主要是为了让网站能够便于分布式部署，也就是将不同的模块部署到不同<br>的服务器上。常用的分布式方案有如下几种。<br>3.1 分布式应用和服务。<br>3.2 分布式静态资源。<br>3.3 分布式数据和存储<br>3.4 分布式计算。<br>3.5 此外还有分布式配置，分布式锁，分布式文件系统等。<br>4，集群。<br>分布式方案只是将不同的模块或服务独立部署到服务器上，但通常还是单台服务器。集群则是将同一个<br>模块或服务同时部署到多台服务器上，通过负载均衡设备对外提供服务。<br>5，缓存。<br>常用的缓存有如下几种，CDN，反向代理，本地缓存，分布式缓存。<br>6，异步。<br>异步一般通过队列的方式来实现。在单一服务器中，可以通过多线程共享内存队列实现异步。在分布式<br>系统中，可以通过分布式消息队列实现。<br>异步有一些作用，描述如下。<br>6.1，提高系统可用性。<br>6.2，加快网站响应速度。<br>6.3，消除并发访问高峰。<br>7，冗余<br>冗余的目的是实现高可用性。是通过使用集群来实现的。即使是再小的服务，也要部署到至少2台服务器<br>上。<br>数据库的冗余有冷备份和热备份两种。<br>冗余还包括在异地建立灾备数据中心。<br>8，自动化<br>自动化包括自动化代码管理，自动化部署，自动化测试，自动化安全检查等。<br>9，安全<br>安全主要通过哦密码和手机验证码的方式实现。</p>
<h2 id="2-架构的5大要素是哪5大要素？"><a href="#2-架构的5大要素是哪5大要素？" class="headerlink" title="2.架构的5大要素是哪5大要素？"></a>2.架构的5大要素是哪5大要素？</h2><p>1.高性能架构<br>2.高可用架构<br>3.伸缩性架构<br>4.可扩展架构<br>5.安全架构</p>
<h2 id="3-说说什么是集群，什么是分布式。"><a href="#3-说说什么是集群，什么是分布式。" class="headerlink" title="3.说说什么是集群，什么是分布式。"></a>3.说说什么是集群，什么是分布式。</h2><p>集群: 多台服务器来完成业务处理，业务请求来了以后，每一台服务器都能独立的完成业务计算；每个服<br>务器都是独立的个体；多台服务器集合起来，通常也需要做负载均衡；<br>分布式：多台服务器完成业务处理，也去请求来了以后，需要多个服务器合作来完成，比方说一个业务<br>处理有5个环节，可能在处理的时候，A服务器处理第一个环节，B服务器处理第二个化解，C服务器处理<br>第三个环节，D服务器处理第四个环节，E服务器来处理第五个环节；一个业务请求的5个环节，被五台<br>服务器来合作完成了一个业务连，此类架构叫分布式架构；</p>
<h2 id="4-说说对Redis的理解"><a href="#4-说说对Redis的理解" class="headerlink" title="4.说说对Redis的理解"></a>4.说说对Redis的理解</h2><p>Redis是一种基于键值对的NoSQL数据库（非关系型数据库）；是一个key-value存储系统<br>Redis有两个特点：高能性 可靠性<br>高能性：Redis将所有数据都存储在内存中，所有读写性特别高<br>可靠性：Redis将内存中的数据利用RDB和AOF的形式保存到硬盘中，这样就可以避免发生断点或机器故<br>障时内存数据丢失的问题<br>功能应用：<br>1.数据缓存功能，减少对数据库的访问压力<br>2.消息队列功能(轻量级): Redis提供了发布订阅功能和阻塞队列功能<br>3.计数器-应用保存用户凭证<br>比如计算浏览数，如果每次操作都要做数据库的对应更新操作，那将会给数据库的性能带来极大的挑战<br>缓存：优化网站性能，首页 （不常变的信息）<br>存储：单点登录，购物车<br>计数器：登录次数限制，incr<br>时效性：验证码expire<br>订单号：数字<br>redis有哪些应用场景场景？<br>1.缓存数据服务器<br>eg: SSO单点登录<br>2.应对高速读写的场景<br>eg: 秒杀高可用<br>3.分布式锁<br>eg: 秒杀数据一致性<br>4.数据共享<br>eg: 库存数据</p>
<h2 id="5-你所了解的NoSql除了Redis还有哪些？"><a href="#5-你所了解的NoSql除了Redis还有哪些？" class="headerlink" title="5.你所了解的NoSql除了Redis还有哪些？"></a>5.你所了解的NoSql除了Redis还有哪些？</h2><p>Memcache&#x2F;MongoDb</p>
<h2 id="6-谈谈对消息队列的理解"><a href="#6-谈谈对消息队列的理解" class="headerlink" title="6.谈谈对消息队列的理解"></a>6.谈谈对消息队列的理解</h2><p>对于传统的应用程序，如果需要向另一个应用程序发送信息，只需要向其发出请求即可！这种方式虽然<br>简单直接，但是如果应用程序2突然挂了，应用程序1可能会因为服务异常，而无法继续提供服务！<br>设想一下，在应用程序1和应用程序2之间，插入一个消息服务，主要用于接受消息和发送消息，这样应<br>用程序1和应用程序2之间的依赖关系就解耦了，同时也不会因为任何一方当服务不可用时，无法继续提<br>供服务！<br>其中插入的消息服务被称为消息队列！<br>消息队列带来的优势：<br>1.程序解耦：应用程序1和应用程序2在进行交互时，不会因为一方服务中断而导致服务停止；<br>2.异步处理：程序解耦之后，带来的最大的好处就是可以异步处理，应用程序1只管把消息发送到消息中<br>间件，应用程序2只需要从消息中间件中接受消息然后进行处理即可；<br>同时，基于异步处理特性，在某些业务场景下，例如商品秒杀活动，引入消息队列之后，当客户端请求<br>量很大的时候，可以有效的进行流量削峰！<br>如果没有中间层做缓冲，当进行商品秒杀时，一下突然大量请求涌入，很可能造成系统直接瘫痪，甚至<br>宕机！<br>消息队列也会带来很明显的弊端：<br>1.系统可用性降低：在引入消息队列之前，你不用考虑消息丢失或者消息队列服务挂掉等等的情况，但<br>是引入消息队列之后你就需要去考虑这些问题！<br>2.系统复杂性提高：加入消息队列之后，你需要保证消息没有被重复消费、处理消息没有被正确处理的<br>情况等等问题！<br>引入消息队列虽然会带来一些问题，俗话说，兵来将挡、水来土掩，这句话同样适用于 IT 开发者，有坑<br>填坑！<br>对于系统可用性降低方面，通常常用的解决方案就是搭建消息服务集群，具体技术实现上可以是主从架<br>构或者分布式架构，即时一台消息队列服务机器挂了，也不会影响消息队列无法提供服务！<br>对于系统复杂性提高方面，常用的解决方案也很多，例如接受者接受到消息之后，可以先将消息写入数<br>据库，即时没有被正确处理，还可以走人工处理，或者消息消费失败，将消息重新入队等待下一次消费<br>等等。</p>
<h2 id="7-说说你对数据库读写分离的理解"><a href="#7-说说你对数据库读写分离的理解" class="headerlink" title="7.说说你对数据库读写分离的理解"></a>7.说说你对数据库读写分离的理解</h2><p>读写分离，基本的原理是让主数据库处理事务性增、改、删操作（INSERT、UPDATE、DELETE），而<br>从数据库处理SELECT查询操作。数据库复制被用来把事务性操作导致的变更同步到集群中的从数据库。<br>为什么要分库、分表、读写分？<br>单表的数据量限制，当单表数据量到一定条数之后数据库性能会显著下降。数据多了之后，对数据库的<br>读、写就会很多。分库减少单台数据库的压力。接触过几个分库分表的系统，都是通过主键进行散列分<br>裤分表的。这类数据比较特殊，主键就是唯一的获取该条信息的主要途径。比如：京东的订单、财付通<br>的交易记录等。。。该类数据的用法，就是通过订单号、交易号来查询该笔订单、交易。<br>还有一类数据，比如用户信息，每个用户都有系统内部的一个userid，与userid对应的还有用户看到的<br>登录名。那么如果分库分表的时候单纯通过userid进行散列分库，那么根据登录名来获取用户的信息，<br>就无法知道该用户处于哪个数据库中。</p>
<h2 id="8-如果你的系统功能中出现性能问题，说说你的排查计划。"><a href="#8-如果你的系统功能中出现性能问题，说说你的排查计划。" class="headerlink" title="8.如果你的系统功能中出现性能问题，说说你的排查计划。"></a>8.如果你的系统功能中出现性能问题，说说你的排查计划。</h2><p>通过浏览器访问，定位到性能最差（耗时最长）的请求,然后定位是代码层面的性能损失，还是数据库层<br>面的性能损失，然后根据不同环节出现的性能问题再加以解决。</p>
<h2 id="9-请列出常见的缓存方式，并简要概述其优缺点。"><a href="#9-请列出常见的缓存方式，并简要概述其优缺点。" class="headerlink" title="9.请列出常见的缓存方式，并简要概述其优缺点。"></a>9.请列出常见的缓存方式，并简要概述其优缺点。</h2><p>客户端缓存，本地缓存，反向代理缓存，分布式缓存；</p>
<h2 id="10-谈谈对通信加密解密的理解。"><a href="#10-谈谈对通信加密解密的理解。" class="headerlink" title="10.谈谈对通信加密解密的理解。"></a>10.谈谈对通信加密解密的理解。</h2><p>加密解密分为：对称可逆加密，非对称可逆加密两大类；<br>可逆加密：加密后得到密文，可以通过加密后的密文得到原文；<br>对称可逆加密特点：有一个公开的加密算法，任何人都知道；有一组Key，分为加密Key和解密Key，且<br>两个Key是相同的；使用当前这个Key加密，可以得到一段密文；同时如果这段密文想要得到原文，也必<br>须得使用这个Key才能解密； 此类被称为对称可逆加密，性能很高，但是安全性较差；只要是key被泄<br>密了，密文就可以被攻破得到原文；因为加密算法是公开的；<br>非对称可逆加密特点：：有一个公开的加密算法，任何人都知道；同时有一对Key,这一组Key是成套的，<br>两个Key不相同，二者且不能相互推导；一个Key作为加密Key，一个Key作为解密Key，且加密Key加密<br>后，只能由这个解密Key才能解开；此类被称为非对称可逆加密；<br>在非对称可逆加密的应用中，有一个公钥和私钥的概念；公钥：把其中的一个Key公开，私钥：把其中<br>的一个Key私有化；那这样就有一下场景：<br>1.公开加密Key，私有解密Key：那么任何一个拥有公开加密Key的人给我这个拥有私有解密Key的人发密<br>文，我都能解开，且只有我能解开；这样就可以保证在通信传输的时候，保证信息的安全；在传输的时<br>候不会被泄密，因为就算在传输的过程中，密文被拦截了，也无法得到原文；因为没有这个解密Key，<br>有密文是无法得到原文的；<br>2.公开解密Key,私有化加密Key: 那么任何一个拥有解密Key的人都能够接收到来自于我这个拥有加密Key<br>的人发送的消息，只要是我这个私有的加密Key加密后的密文，任何一个拥有解密Key的人都能够解开密<br>文得到原文；那这样就可以实现一个功能：防止抵赖，也就是说，如果我是有解密Key的人，我得到的<br>密文只要能够解开，那就说明这段密文一定是拥有加密Key的人发出来的；不然我是解不开这段密文<br>的；</p>
<h2 id="11-CTS、CLS、CLR分别作何解释？"><a href="#11-CTS、CLS、CLR分别作何解释？" class="headerlink" title="11.CTS、CLS、CLR分别作何解释？"></a>11.CTS、CLS、CLR分别作何解释？</h2><p>CTS：Common Type System 通用系统类型，一种确定公共语言运行库如何定义，使用和管理类型的规<br>范。<br>Int32、Int16-&gt;int、String-&gt;string、Boolean-&gt;bool，前者都是.Net中的类型，后者是C#中对这些类型<br>的别名。<br>CLR：Common Language Runtime 公共语言运行时，也即使项目运行需要的环境，就如我们人生存需<br>要水。<br>CLS：Common Language Specification 通用语言规范，要和其他对象完全交互，而不管这些对象是以<br>何种语言实现的，对象必须只向调用方公开那些它们必须与之互用的所有语言的通用功能。为此定义了<br>公共语言规范 (CLS)，它是许多应用程序所需的一套基本语言功能。</p>
<h2 id="12-PDB是什么东西-在调试中它应该放在哪里？"><a href="#12-PDB是什么东西-在调试中它应该放在哪里？" class="headerlink" title="12.PDB是什么东西? 在调试中它应该放在哪里？"></a>12.PDB是什么东西? 在调试中它应该放在哪里？</h2><p>PDB是用于保存调试和项目状态信息的文件，在debug的时候将产生pdb文件，调试的时候应该放在和<br>对应应用程序集相同目录。</p>
<h2 id="13-C-中Params是什么含义？有何用途？"><a href="#13-C-中Params是什么含义？有何用途？" class="headerlink" title="13.C#中Params是什么含义？有何用途？"></a>13.C#中Params是什么含义？有何用途？</h2><p>Params 关键字在方法成员的参数列表中使用，为该方法提供了参数个数可变的能力<br>它在只能出现一次并且不能在其后再有参数定义，之前可以<br>实例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApplication1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">App</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//第一个参数必须是整型，但后面的参数个数是可变的。</span></span><br><span class="line">        <span class="comment">//而且由于定的是object数组，所有的数据类型都可以做为参数传入</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UseParams</span>(<span class="params"><span class="built_in">int</span> id, <span class="keyword">params</span> <span class="built_in">object</span>[] list</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(id);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//可变参数部分传入了三个参数，都是字符串类型</span></span><br><span class="line">            UseParams(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">            <span class="comment">//可变参数部分传入了四个参数，分别为字符串、整数、浮点数和双精度浮点数数组</span></span><br><span class="line">            UseParams(<span class="number">2</span>, <span class="string">&quot;d&quot;</span>, <span class="number">100</span>, <span class="number">33.33</span>, <span class="keyword">new</span> <span class="built_in">double</span>[] &#123; <span class="number">1.1</span>, <span class="number">2.2</span> &#125;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line"><span class="number">2</span></span><br><span class="line">d</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">33.33</span></span><br><span class="line">System.Double[]</span><br></pre></td></tr></table></figure>


<h2 id="14-说说对http-301、302、303，304、400、405、415状态码的认识；"><a href="#14-说说对http-301、302、303，304、400、405、415状态码的认识；" class="headerlink" title="14.说说对http 301、302、303，304、400、405、415状态码的认识；"></a>14.说说对http 301、302、303，304、400、405、415状态码的认识；</h2><p>301表示永久重定向（301 moved permanently），表示请求的资源分配了新url，以后应使用新url。<br>302表示临时性重定向（302 found），请求的资源临时分配了新url，本次请求暂且使用新url。302与<br>301的区别是，302表示临时性重定向，重定向的url还有可能还会改变。<br>303 表示请求的资源路径发生改变，使用GET方法请求新url。她与302的功能一样，但是明确指出使用<br>GET方法请求新url。<br>304 not modified<br>客户端发送附带条件的请求时（if-matched,if-modified-since,if-none-match,if-range,if-unmodifiedsince<br>任一个）服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回<br>304Modified（服务器端资源未改变，可直接使用客户端未过期的缓存）。304状态码返回时，不包含任<br>何响应的主体部分。304虽然被划分在3xx类别中，但是和重定向没有关系。<br>400 bad request<br>表示请求的报文中存在语法错误，比如url含有非法字符。提交json时，如果json格式有问题，接收端接<br>收json，也会出现400 bad request，比如常见的json串，数组不应该有”,但是有”了。<br>405 method not allowed<br>问题原因： 请求的方式（get、post、delete）方法与后台规定的方式不符合。比如： 后台方法规定的<br>请求方式只接受get，如果用post请求，就会出现 405 method not allowed的提示<br>415<br>后台程序不支持提交的content-type，就会返回415，spring mvc错误信息如下<br>The server refused this request because the request entity is in a format not supported by the<br>requested resource for the requested method.<br>unsupported media type</p>
<h2 id="15-请使用C-的相关知识，封装一个泛型的数据库访问查询方法；"><a href="#15-请使用C-的相关知识，封装一个泛型的数据库访问查询方法；" class="headerlink" title="15.请使用C#的相关知识，封装一个泛型的数据库访问查询方法；"></a>15.请使用C#的相关知识，封装一个泛型的数据库访问查询方法；</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">Get</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">int</span> id</span>) <span class="keyword">where</span> T : BaseModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> ConnectionString = <span class="string">&quot;Data Source=DESKTOP-63QE7M1;</span></span><br><span class="line"><span class="string">    Database=CustomerDB; User ID=sa; Password=sa123;</span></span><br><span class="line"><span class="string">    MultipleActiveResultSets=True&quot;</span>;</span><br><span class="line">    Type type = <span class="keyword">typeof</span>(T);</span><br><span class="line">    <span class="keyword">var</span> propList = type.GetProperties().Select(p =&gt; <span class="string">$&quot;[<span class="subst">&#123;p.Name&#125;</span>]&quot;</span>);</span><br><span class="line">    <span class="built_in">string</span> props = <span class="built_in">string</span>.Join(<span class="string">&#x27;,&#x27;</span>, propList);</span><br><span class="line">    <span class="built_in">string</span> tableName = type.Name;</span><br><span class="line">    <span class="built_in">string</span> StringSql = <span class="string">$&quot;select <span class="subst">&#123;props&#125;</span> from [<span class="subst">&#123;tableName&#125;</span>] where id=&quot;</span> + id;</span><br><span class="line">    <span class="built_in">object</span> oInstance = Activator.CreateInstance(type);</span><br><span class="line">    <span class="keyword">using</span> (SqlConnection connection = <span class="keyword">new</span></span><br><span class="line">    SqlConnection(ConnectionString))</span><br><span class="line">    &#123;</span><br><span class="line">        connection.Open();</span><br><span class="line">        SqlCommand sqlCommand = <span class="keyword">new</span> SqlCommand(StringSql, connection);</span><br><span class="line">        SqlDataReader reader = sqlCommand.ExecuteReader();</span><br><span class="line">        reader.Read();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> type.GetProperties())</span><br><span class="line">        &#123;</span><br><span class="line">        	prop.SetValue(oInstance, reader[prop.Name]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T)oInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="16-什么是异步编程？"><a href="#16-什么是异步编程？" class="headerlink" title="16.什么是异步编程？"></a>16.什么是异步编程？</h2><p>1.异步编程就是在方法调用后立即返回，不会阻塞后续代码执行。<br>2.异步代码执行完毕后一般会通过回调的形式调用指定的方法，从而完成异步代码块与主代码块（主线<br>程）的通讯。<br>3.javascript中的异步编程能力都是由浏览器提供的，如setTimeout， XMLHttpRequest，还有DOM的<br>事件机制，还有HTML5新增加的webwork, postMessage，等等很多。这些东西都有一个共同的特点，<br>就是拥有一个回调函数。<br>4.消除需要长时间执行的代码块阻塞整个代码的执行。<br>5.延迟执行一段代码。</p>
<h2 id="17-架构模式-Architectural-Pattern-设计模式-Design-Pattern-代"><a href="#17-架构模式-Architectural-Pattern-设计模式-Design-Pattern-代" class="headerlink" title="17.架构模式(Architectural Pattern) 设计模式(Design Pattern) 代"></a>17.架构模式(Architectural Pattern) 设计模式(Design Pattern) 代</h2><p>码模式(Coding Pattern)的区别是什么？<br>区别：在于三种不同的模式存在于它们各自的抽象层次和具体层次。<br>架构模式是一个系统的高层次策略，涉及到大尺度的组件以及整体性质。架构模式的好坏可以影响到总<br>体布局和框架性结构。<br>计模式是中等尺度的结构策略。这些中等尺度的结构实现了一些大尺度组件的行为和它们之间的关系。<br>模式的好坏不会影响到系统的总体布局和总体框架。设计模式定义出子系统或组件的微观结构。<br>码模式是特定的范例和与特定语言有关的编程技巧。代码模式的好坏会影响到一个中等尺度组件的内<br>部、外部的结构或行为的底层细节，但不会影响到一个部件或子系统的中等尺度的结构，更不会影响到<br>系统的总体布局和大尺度框架</p>
<h2 id="18-软件架构的目标是什么？"><a href="#18-软件架构的目标是什么？" class="headerlink" title="18.软件架构的目标是什么？"></a>18.软件架构的目标是什么？</h2><p>可靠性（Reliable）：<br>–软件系统对于用户的商业经营和管理来说极为重要，因此软件系统必须非常可靠。<br>全性（Secure） ：<br>–软件系统所承担的交易的商业价值极高，系统的安全性非常重要。<br>可伸缩性（Scalable） ：<br>–软件必须能够在用户的使用率、用户的数目增加很快的情况下，保持合理的性能。只有这样，才能适应<br>用户的市场扩展得可能性。<br>可定制化（Customizable） ：<br>–同样的一套软件，可以根据客户群的不同和市场需求的变化进行调整。<br>可扩展性（Extensible）：<br>–在新技术出现的时候，一个软件系统应当允许导入新技术，从而对现有系统进行功能和性能的扩展<br>维护性（Maintainable）：<br>–软件系统的维护包括两方面，一是排除现有的错误，二是将新的软件需求反映到现有系统中去。一个易<br>于维护的系统可以有效地降低技术支持的花费。<br>{<br>connection.Open();<br>SqlCommand sqlCommand &#x3D; new SqlCommand(StringSql, connection);<br>SqlDataReader reader &#x3D; sqlCommand.ExecuteReader();<br>reader.Read();<br>foreach (var prop in type.GetProperties())<br>{<br>prop.SetValue(oInstance, reader[prop.Name]);<br>}<br>}<br>return (T)oInstance;<br>}<br>客户体验（Customer Experience）：<br>–软件系统必须易于使用。<br>市场时机（Time to Market）：<br>–软件用户要面临同业竞争，软件提供商也要面临同业竞争。以最快的速度争夺市场先机非常重要。</p>
<h2 id="19-什么是迪米特法则？"><a href="#19-什么是迪米特法则？" class="headerlink" title="19.什么是迪米特法则？"></a>19.什么是迪米特法则？</h2><p>在软件系统中，一个模块设计得好不好的标志，就是该模块在多大的程度上将自己的内部数据和其他与<br>实现有关的细节隐藏起来。这一概念就是“信息的隐藏”，或者叫做“封装”，也就是大家熟悉的软件设计的<br>基本教义之一。<br>信息的隐藏非常重要的原因在于，它可以使各个子系统之间脱耦。这种脱耦化可以有效地加快系统的开<br>发过程，因为可以独立地同时开发各个模块。它可以使维护过程变得容易，因为所有的模块都容易读<br>懂，特别是不必担心对其他模块的影响。<br>旦确认某一个模块是性能的障碍时，设计人员可以到对这个模块本身进行优化，而不必担心影响到其他<br>的模块。 信息的隐藏可以促进软件的复用。一个系统的规模越大，信息的隐藏就越是重 要，而信息隐藏<br>的威力也就越明显。</p>
<h2 id="20-解释一下里氏替换原则？"><a href="#20-解释一下里氏替换原则？" class="headerlink" title="20.解释一下里氏替换原则？"></a>20.解释一下里氏替换原则？</h2><p>里氏代换原则的严格表达是：一个软件实体如果使用的是一个基类的话，那么一定适用于其子类，而且<br>它 根本不能察觉出基类对象和子类对象的区别。<br>里氏代换原则是继承复用的基石。只有当衍生类可以替换掉基类，软件单位的功能不会受到影响时，基<br>类才能真正被复用，而衍生类也才能够在基类的基础上增加新的行为。</p>
<h2 id="21-什么是依赖倒转IOC原则？"><a href="#21-什么是依赖倒转IOC原则？" class="headerlink" title="21.什么是依赖倒转IOC原则？"></a>21.什么是依赖倒转IOC原则？</h2><p>在面向对象的系统里面，两个类之间可以发生三种不同的耦合关系：<br>–零耦合关系：如果两个类没有耦合关系，就称之为零耦合。<br>–具体耦合关系：具体耦合发生在两个具体的(可实例化 的)类之间，经出一个类对另外一个具体类的直接<br>引用造成。<br>–抽象耦合关系：抽象耦合关系发生在一个具体类和一个抽象类之间，使两个必须发生关系的类之间存有<br>最大的灵活性。<br>简单地说，依赖倒转原则要求客户端依赖于抽象耦合</p>
<h2 id="22-为何说基于-SOAP-的服务是重量级的服务，Rest是轻量级的？"><a href="#22-为何说基于-SOAP-的服务是重量级的服务，Rest是轻量级的？" class="headerlink" title="22.为何说基于 SOAP 的服务是重量级的服务，Rest是轻量级的？"></a>22.为何说基于 SOAP 的服务是重量级的服务，Rest是轻量级的？</h2><p>Restful Web服务是一种基于 REST 和 HTTP 协议的轻量级Web 服务，它把Web应用系统中的一切都当<br>作是资源，它利用标准的HTTP请求方法（GET、POST、PUT 和 DELETE等），以URL的形式访问(功能<br>调用)Web资源。<br>JAVA中共有三种Web Service规范，分别JAX-WS(JAX-RPC)、JAX-RS、JAXM&amp;SAAJ。其中有两种SOAP<br>Web Service规范：JAX-WS和SAAJ。JAX-RS是Rest服务定义。使用最多的是JAX-WS和JAX-RS。<br>JAX-RS (JSR 311) JAX-WS (JSR 224)<br>适用范围 适用于简单的远程数据访问 适用于复杂的数据交互模式<br>消息传输 请求和响应通过 HTTP 消息正文来传输 请求和响应被放在 SOAP 消息，作为传输层（HTTP,<br>JMS, SMTP 等）消息正文进行传输<br>客户端调用 只需要一个 URL就能调用 Web 服务 需要编写标准的客户端代码，对 Web Services进行访<br>问<br>安全性 简单的认证和授权机制 丰富的安全策略，可实现各种安全需求<br>访问终端 桌面浏览器或移动终端浏览器 桌面、浏览器<br>Java EE6引入了对JSR-311的支持。JSR-311（JAX-RS：Java API for RESTful Web Services）旨在定义一<br>个统一的规范，使得 Java 程序员可以使用一套固定的接口来开发 REST 应用，避免了依赖于第三方框<br>架。同时，JAX-RS使用POJO编程模型和基于标注的配置，并集成JAXB，从而可以有效缩短 REST 应用的<br>开发周期。<br>JAX-RS定义的API位于javax.ws.rs包中。<br>JAX-RS的具体实现由第三方提供，例如Sun的参考实现 Jersey、Apache 的 CXF以及JBoss的RESTEasy<br>等。<br>SOAP比较复杂，基于XML，有对应规范；REST利用HTTP请请求方式GET，POST，PUT约定事务操作。<br>简单的说，SOAP通过传输XML，XML定义了请求和响应的具体数据，要进行的操作等等；而REST则是<br>另一种约定，比如请求&#x2F;user&#x2F;1001这个RUL，GET方式返回id为1001的user信息，POST方式则是更新id<br>为1001的user信息，DELETE删除等。</p>
<h2 id="23-基于REST-和基于SOAP的服务的区别是什么？"><a href="#23-基于REST-和基于SOAP的服务的区别是什么？" class="headerlink" title="23.基于REST 和基于SOAP的服务的区别是什么？"></a>23.基于REST 和基于SOAP的服务的区别是什么？</h2><p>传统的 Web 服务通过简单对象访问协议 (SOAP) 进行消息的交换。它是一种用于一单向通信的消息格<br>式，将消息组合成 XML 文档。描述了消息的传输，主要是通过 HTTP 协议。它定义一组 RPC 调用与<br>SOAP 消息互相转换的契约，将 RPC 调用封装为 SOAP 消息进行传输，并在服务器端反向转换为服务器<br>端 RPC 调用，最终结果再以类似机制返回给客户端。<br>基于 SOAP 的服务是重量级的服务，因为它有严格的约束和标准，开发人员需要深入了解基于 SOAP 的<br>web 服务中用到的关键技术：XML，WSDL、SOAP 及 UDDI，这样就缺少了开发的灵活性。<br>相比基于 XML 技术的其它臃肿的 web 服务而言，REST 显得更加简洁，更轻量级。增删查改是应用软件<br>里面最常见的操作，而在 HTTP 方法中，正好有其对应的方法实现，所以可以有效的降低复杂度。同时<br>也能够满足异构平台之间的交互。<br>当前，基于SOAP的服务和REST二者都有一定的应用场景，互联网上的很多应用，同时提供基于SOAP的<br>服务和REST。</p>
<h2 id="24-工厂模式-简单工厂模式-抽象工厂模式三者有什么区别"><a href="#24-工厂模式-简单工厂模式-抽象工厂模式三者有什么区别" class="headerlink" title="24.工厂模式,简单工厂模式,抽象工厂模式三者有什么区别"></a>24.工厂模式,简单工厂模式,抽象工厂模式三者有什么区别</h2><p>工厂模式，也叫做说虚构造器，在简单工厂中间插入了一个具体产品工厂，这个工厂知道产品构造时候<br>的具体细节，而简单工厂模式的产品具体构造细节是在一个个if&#x2F;else分支，或者在switch&#x2F;case分支里面<br>的。工厂模式的好处就在于将工厂和产品之间的耦合降低，将具体产品的构造过程放在了具体工厂类里<br>面。在以后扩展产品的时候方便很多，只需要添加一个工厂类，一个产品类，就能方便的添加产品，而<br>不需要修改原有的代码。而在简单工厂中，如果要增加一个产品，则需要修改工厂类，增加if&#x2F;else分<br>支，或者增加一个case分支，工厂模式符合软件开发中的OCP原则（open close principle），对扩展开<br>放，对修改关闭。<br>抽象工厂模式：这个模式我总是感觉和builder模式非常相似。<br>工厂方法模式提供的是对一个产品的等级模式，，而抽象工厂方法提供的是对多个产品的等级模式，注<br>意，这里的多个具体产品之间是相互耦合的，也就是说这里的抽象工厂提供的产品之间是存在某种联系<br>的。<br>有人做如下的比较：<br>工厂方法模式：一个抽象产品类，可以派生出多个具体产品类。<br>一个抽象工厂类，可以派生出多个具体工厂类。<br>每个具体工厂类只能创建一个具体产品类的实例。<br>抽象工厂模式：多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。<br>一个抽象工厂类，可以派生出多个具体工厂类。<br>每个具体工厂类可以创建多个具体产品类的实例。<br>区别：工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。<br>工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。<br>下面是一个形象的比喻：<br>无论是简单工厂模式、工厂模式还是抽象工厂模式，它们本质上都是将不变的部分提取出来，将可变的<br>部分留作接口，以达到最大程度上的复用。拿一个生产水杯（cup）的工厂举例：起初，不用工厂模<br>式，我必须在生产水杯之前知道水杯的材料和形状等水杯的所有特征才能生产，这就是我们的new<br>Cup();这个Cup必须是具体的。厂主发现同一形状的被子，只是材料不同,如一个是玻璃(glass)的，一个<br>是瓷(china)的,但是确要两条生产线，显然有资源浪费的嫌疑。现在厂主生产杯子时先不让生产线知道我<br>要产的是玻璃的还是瓷的，而是让它在不知道具体材料的情况下先做它能做的，等到它把模具做好，只<br>需要向其中填充玻璃原料或者瓷原料就可以造出同一形状的具体杯子了。但是很可惜，java并不能new<br>一个抽象的Cup，所以就有了简单工厂模式。原来是Cup cup&#x3D;new Cup;现在是<br>SimpleCupFactory.createCup(String cupName),根据cup的名字生产Cup,而createCup返回的是一个实<br>现了 Cup接口或抽象类的具体Cup。简单抽象工厂模式有一个问题，就是当我现在想生产一个同样形状<br>的铁杯时，工厂里并没有定义相应的处理流程，只能更改createCup方法，这就不合理了。我现在只是<br>想生产铁杯，你只要在最后的时候把玻璃原料换成铁的不就行了吗，干嘛还要更改整条生产线呢？于是<br>就有了工厂模式。原来生产线在生产模具的时候还要考虑是为玻璃杯生产的模具还是为铁杯生产的模<br>具，现在它不用管了。CupFactory.createCup()创建Cup.CupFactory是接口或抽象类。实现它的具体子<br>类会创建符合Cup接口的具体Cup。那么现在厂主想要生产水壶(kettle)，用工厂模式就不得不再造一条<br>水壶生产线，能不能在水杯生产线同时生产水壶呢？这就是抽象工厂模式。在原CupFactory中加一个<br>createKettle()方法，用来生产水壶</p>
<h2 id="25-Session有什么重大BUG，微软提出了什么方法加以解决？"><a href="#25-Session有什么重大BUG，微软提出了什么方法加以解决？" class="headerlink" title="25.Session有什么重大BUG，微软提出了什么方法加以解决？"></a>25.Session有什么重大BUG，微软提出了什么方法加以解决？</h2><p>是iis中由于有进程回收机制，系统繁忙的话Session会丢失，可以用Sate server或SQL Server数据库的<br>方式存储Session不过这种方式比较慢，而且无法捕获Session的END事件。</p>
<h2 id="26-NET下内存分配机制是什么？"><a href="#26-NET下内存分配机制是什么？" class="headerlink" title="26.NET下内存分配机制是什么？"></a>26.NET下内存分配机制是什么？</h2><p>对于值类型的实例，CLR在运行时有两种分配方式：(1) 如果该值类型的实例作为类型中的方法(Method)<br>中的局部变量，则该实例被创建在线程栈上；(2) 如果该值类型的实例作为类型的成员，则该实例作为引<br>用类型(引用类型在GC堆或者LOH上创建)的实例的一部分，被创建在GC堆上。<br>对于引用类型的实例，CLR在运行时也有两种分配方式：(1) 如果该引用类型的实例的Size&lt;85000Byte，<br>则该实例被创建在GC(Garbage Collection)堆上(当CLR在分配和回收对象时，GC可能会对GC堆进行压<br>缩)；(2) 如果该引用类型的实例的Size&gt;&#x3D;85000byte，则该实例被创建在LOH(Large Object Heap)上<br>(LOH不会被压缩)。<br>要注意的是，对于引用对象，他包括了引用和对象实例两部分，实例需要通过对其存储位置的引用来访<br>问，对于private Object o &#x3D; new Object()，其实可以分解为两句话：<br>private Object o；o &#x3D; new Object()；<br>其中private Object o是定义了对象的引用，也就是记录对象实例的指针，而不是对象本身。这个引用存<br>储于堆栈中，占用4个字节；当没有使用o &#x3D; new Object()时，引用本身的值为null，也就是不指向任何<br>有效位置；<br>当o &#x3D; new Object()后，才真正根据对象的大小，在托管堆中分配空间给对象实例，然后将实例的指针位<br>置赋值给前面的引用。这才完成一个对象的实例化。<br>值类型如果嵌套在引用类型时，也就是值类型在内联的结构中时，其内存分配是什么样子呢？ 其实很简<br>单，例如类的私有字段如果为值类型，那它作为引用类型实例的一部分，也分配在托管堆上。<br>引用类型嵌套在值类型时，内存的分配情况为：该引用类型将作为值类型的成员变量，堆栈上将保存该<br>成员的引用，而成员的实际数据还是保存在托管堆中</p>
<h2 id="27-如何提高-NET的性能-？"><a href="#27-如何提高-NET的性能-？" class="headerlink" title="27.如何提高.NET的性能 ？"></a>27.如何提高.NET的性能 ？</h2><p>1 使用异步方式调用Web服务和远程对象<br>只要有可能就要避免在请求的处理过程中对Web服务和远程对象的同步调用，因为它占用的是的<br>ASP.NET 线程池中的工作线程，这将直接影响Web服务器响应其它请求的能力。<br>2 使用适当的Caching策略来提高性能<br>3 判断字符串，不要用””比较。<br>&#x2F;&#x2F;避免<br>if(strABC!&#x3D;null &amp;&amp; strABC!&#x3D;””)<br>{}<br>&#x2F;&#x2F;推荐<br>if(!strABC.IsNullOrEmpty)<br>{}<br>4 页面优化<br>5 用完马上关闭数据库连接<br>6 尽量使用存储过程，并优化查询语句<br>7 只读数据访问用SqlDataReader，不要使用DataSet托管堆中</p>
<h2 id="28-如果你有无穷多的水，一个3公升的提捅，一个5公升的提捅，两只提捅形状上下都不均匀，问你如何才能准确称出4公升的水"><a href="#28-如果你有无穷多的水，一个3公升的提捅，一个5公升的提捅，两只提捅形状上下都不均匀，问你如何才能准确称出4公升的水" class="headerlink" title="28.如果你有无穷多的水，一个3公升的提捅，一个5公升的提捅，两只提捅形状上下都不均匀，问你如何才能准确称出4公升的水?"></a>28.如果你有无穷多的水，一个3公升的提捅，一个5公升的提捅，两只提捅形状上下都不均匀，问你如何才能准确称出4公升的水?</h2><p>3升装满；3升-〉5升（全注入）；3升装满；3升-〉升（剩1升）；5升倒掉;升-〉5 升（注入1升）；3升<br>装满；3升-〉5升；完成（另：可用回溯法编程求解）</p>
<h2 id="29-在一天的24小时之中，时钟的时针、分针和秒针完全重合在一起的时候有几次？都分别是什么时间？你怎样算出来的？"><a href="#29-在一天的24小时之中，时钟的时针、分针和秒针完全重合在一起的时候有几次？都分别是什么时间？你怎样算出来的？" class="headerlink" title="29.在一天的24小时之中，时钟的时针、分针和秒针完全重合在一起的时候有几次？都分别是什么时间？你怎样算出来的？"></a>29.在一天的24小时之中，时钟的时针、分针和秒针完全重合在一起的时候有几次？都分别是什么时间？你怎样算出来的？</h2><p>23次，因为分针要转24圈，时针才能转1圈，而分针和时针重合两次之间的间隔显然&gt;1 小时，它们有23<br>次重合机会，每次重合中秒针有一次重合机会，所以是23次重合时间可以对照手表求出，也可列方程求<br>出</p>
<h2 id="30-一张长方形的桌面上放n个一样大小的圆形硬币。这些硬币中可能有一些不完全在桌面内，也可能有一些彼此重叠；当再多放一个硬币而它的圆心在桌面内时，新放的硬币便必定与原先某些硬币重叠。请证明整个桌面可以用4n个硬币完全覆盖"><a href="#30-一张长方形的桌面上放n个一样大小的圆形硬币。这些硬币中可能有一些不完全在桌面内，也可能有一些彼此重叠；当再多放一个硬币而它的圆心在桌面内时，新放的硬币便必定与原先某些硬币重叠。请证明整个桌面可以用4n个硬币完全覆盖" class="headerlink" title="30.一张长方形的桌面上放n个一样大小的圆形硬币。这些硬币中可能有一些不完全在桌面内，也可能有一些彼此重叠；当再多放一个硬币而它的圆心在桌面内时，新放的硬币便必定与原先某些硬币重叠。请证明整个桌面可以用4n个硬币完全覆盖"></a>30.一张长方形的桌面上放n个一样大小的圆形硬币。这些硬币中可能有一些不完全在桌面内，也可能有一些彼此重叠；当再多放一个硬币而它的圆心在桌面内时，新放的硬币便必定与原先某些硬币重叠。请证明整个桌面可以用4n个硬币完全覆盖</h2><p>要想让新放的硬币不与原先的硬币重叠，两个硬币的圆心距必须大于直径。也就是说，对于桌面上任意<br>一点，到最近的圆心的距离都小于2，所以，整个桌面可以用n个半径为2的硬币覆盖。<br>把桌面和硬币的尺度都缩小一倍，那么，长、宽各是原桌面一半的小桌面，就可以用n个半径为1的硬币<br>覆盖。那么，把原来的桌子分割成相等的4块小桌子，那么每块小桌子都可以用n个半径为1的硬币覆<br>盖，因此，整个桌面就可以用4n个半径为1的硬币覆盖。</p>
<h2 id="31-三名传教士和三个野蛮人同在一个小河渡口，渡口上只有一条可容两人的小船。问题的目标是要用这条小船把这六个人全部渡到对岸去，条件是在渡河的过程中，河两岸随时都保持传教士人数不少于野蛮人的人数，否则野蛮人会把处于少数的传教士吃掉。这六个人怎样才能安全渡过去"><a href="#31-三名传教士和三个野蛮人同在一个小河渡口，渡口上只有一条可容两人的小船。问题的目标是要用这条小船把这六个人全部渡到对岸去，条件是在渡河的过程中，河两岸随时都保持传教士人数不少于野蛮人的人数，否则野蛮人会把处于少数的传教士吃掉。这六个人怎样才能安全渡过去" class="headerlink" title="31.三名传教士和三个野蛮人同在一个小河渡口，渡口上只有一条可容两人的小船。问题的目标是要用这条小船把这六个人全部渡到对岸去，条件是在渡河的过程中，河两岸随时都保持传教士人数不少于野蛮人的人数，否则野蛮人会把处于少数的传教士吃掉。这六个人怎样才能安全渡过去?"></a>31.三名传教士和三个野蛮人同在一个小河渡口，渡口上只有一条可容两人的小船。问题的目标是要用这条小船把这六个人全部渡到对岸去，条件是在渡河的过程中，河两岸随时都保持传教士人数不少于野蛮人的人数，否则野蛮人会把处于少数的传教士吃掉。这六个人怎样才能安全渡过去?</h2><p>1． 一名牧师和一个野蛮人过河；2． 留下野蛮人，牧师返回；3． 两个野蛮人过河；4． 一个野蛮人返<br>回；5． 两名牧师过河；6． 一名牧师和一个野蛮人返回；7． 两名牧师过河；8． 一个野蛮人返回；<br>9． 两个野蛮人过河；10． 一个野蛮人返回；11． 两个野蛮人过河。这里关键的一步是第6步，许多人<br>不能解决此题，就是没有想到这一步。<br>我的思路：实质到第6步时也只是在重复开始前面的思路，先安排3人，再安排2人的情况。只要抓住“传<br>教士大于等于野蛮人”这个要点分配即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.zzonn.com/2020/05/20/C#.NET%E9%97%AE%E7%AD%94%20%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6%E7%AF%87-cnet-wen-da-gao-ji-jin-jie-pian/" data-id="clf0jcv6p000a6ocx2j93bzhd" data-title="C#.NET问答 高级进阶篇" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C#</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-C#.NET问答 基础篇-cnet-wen-da-ji-chu-pian" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/19/C#.NET%E9%97%AE%E7%AD%94%20%E5%9F%BA%E7%A1%80%E7%AF%87-cnet-wen-da-ji-chu-pian/" class="article-date">
  <time class="dt-published" datetime="2020-05-19T06:04:48.000Z" itemprop="datePublished">2020-05-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Net/">.Net</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/19/C#.NET%E9%97%AE%E7%AD%94%20%E5%9F%BA%E7%A1%80%E7%AF%87-cnet-wen-da-ji-chu-pian/">C#.NET问答 基础篇</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-C-中堆和栈的区别？"><a href="#1-C-中堆和栈的区别？" class="headerlink" title="1.C#中堆和栈的区别？"></a>1.C#中堆和栈的区别？</h2><p>栈：由编译器自动分配、释放。在函数体中定义的变量通常在栈上。 堆：一般由程序员分配释放。用<br>new、malloc等分配内存函数分配得到的就是在堆上。<br>存放在栈中时要管存储顺序，保持着先进后出的原则，他是一片连续的内存域，有系统自动分配和维<br>护；<br>堆：是无序的，他是一片不连续的内存域，有用户自己来控制和释放，如果用户自己不释放的话，当内<br>存达到一定的特定值时，通过垃圾回收器(GC)来回收。<br>栈内存无需我们管理，也不受GC管理。当栈顶元素使用完毕，立马释放。而堆则需要GC清理。<br>使用引用类型的时候，一般是对指针进行的操作而非引用类型对象本身。但是值类型则操作其本身</p>
<h2 id="2-C-中的委托是什么？事件是不是一种委托？"><a href="#2-C-中的委托是什么？事件是不是一种委托？" class="headerlink" title="2.C#中的委托是什么？事件是不是一种委托？"></a>2.C#中的委托是什么？事件是不是一种委托？</h2><p>委托的本质是一个类，委托是将一种方法作为参数代入到另一种方法。 事件是委托的实例，事件是一种<br>特殊的委托。 &#x2F;&#x2F;比如：onclick事件中的参数就是一种方法。</p>
<h2 id="3-C-静态构造函数特点是什么？"><a href="#3-C-静态构造函数特点是什么？" class="headerlink" title="3.C#静态构造函数特点是什么？"></a>3.C#静态构造函数特点是什么？</h2><p>最先被执行的构造函数，且在一个类里只允许有一个无参的静态构造函数<br>执行顺序：静态变量&gt;静态构造函数&gt;实例变量&gt;实例构造函数</p>
<h2 id="4-CTS、CLS、CLR分别作何解释"><a href="#4-CTS、CLS、CLR分别作何解释" class="headerlink" title="4.CTS、CLS、CLR分别作何解释"></a>4.CTS、CLS、CLR分别作何解释</h2><p>CTS：通用语言系统。CLS：通用语言规范。CLR：公共语言运行库。<br>CTS：Common Type System 通用类型系统。Int32、Int16→int、String→string、Boolean→bool。<br>每种语言都定义了自己的类型，.NET通过CTS提供了公共的类型，然后翻译生成对应的.NET类型。<br>CLS：Common Language Specification 通用语言规范。不同语言语法的不同。每种语言都有自己的语<br>法，.NET通过CLS提供了公共的语法，然后不同语言翻译生成对应的.NET语法。<br>CLR：Common Language Runtime 公共语言运行时，就是GC、JIT等这些。有不同的CLR，比如服务器<br>CLR、Linux CLR（Mono）、Silverlight CLR(CoreCLR)。相当于一个发动机，负责执行IL。</p>
<h2 id="5-C-中什么是值类型与引用类型？"><a href="#5-C-中什么是值类型与引用类型？" class="headerlink" title="5.C#中什么是值类型与引用类型？"></a>5.C#中什么是值类型与引用类型？</h2><p>值类型：struct、enum、int、float、char、bool、decimal<br>引用类型：class、delegate、interface、array、object、string</p>
<h2 id="6-请详述在C-中类-class-与结构-struct-的异同？"><a href="#6-请详述在C-中类-class-与结构-struct-的异同？" class="headerlink" title="6.请详述在C#中类(class)与结构(struct)的异同？"></a>6.请详述在C#中类(class)与结构(struct)的异同？</h2><p>class可以被实例化,属于引用类型,<br>class可以实现接口和单继承其他类,还可以作为基类型,是分配在内存的堆上的<br>struct属于值类型,不能作为基类型,但是可以实现接口,是分配在内存的栈上的.</p>
<h2 id="7-new关键字的作用"><a href="#7-new关键字的作用" class="headerlink" title="7.new关键字的作用"></a>7.new关键字的作用</h2><p>运算符：创建对象实例<br>修饰符：在派生类定义一个重名的方法，隐藏掉基类方法<br>约束：泛型约束定义，约束可使用的泛型类型</p>
<h2 id="8-int-和int有什么区别"><a href="#8-int-和int有什么区别" class="headerlink" title="8.int?和int有什么区别"></a>8.int?和int有什么区别</h2><p>int？为可空类型，默认值可以是null<br>int默认值是0<br>int?是通过int装箱为引用类型实现</p>
<h2 id="9-C-中值传递与引用传递的区别是什么？"><a href="#9-C-中值传递与引用传递的区别是什么？" class="headerlink" title="9.C#中值传递与引用传递的区别是什么？"></a>9.C#中值传递与引用传递的区别是什么？</h2><p>值传递时，系统首先为被调用方法的形参分配内存空间，并将实参的值按位置一一对应地复制给形参，<br>此后，被调用方法中形参值得任何改变都不会影响到相应的实参；<br>引用传递时，系统不是将实参本身的值复制后传递给形参，而是将其引用值（即地址值）传递给形参，<br>因此，形参所引用的该地址上的变量与传递的实参相同，方法体内相应形参值得任何改变都将影响到作<br>为引用传递的实参。<br>简而言之，按值传递不是值参数是值类型，而是指形参变量会复制实参变量，也就是会在栈上多创建一<br>个相同的变量。而按引用传递则不会。可以通过 ref 和 out 来决定参数是否按照引用传递。</p>
<h2 id="10-C-中参数传递-ref-与-out-的区别？"><a href="#10-C-中参数传递-ref-与-out-的区别？" class="headerlink" title="10.C#中参数传递 ref 与 out 的区别？"></a>10.C#中参数传递 ref 与 out 的区别？</h2><p>（1）ref指定的参数在函数调用时必须先初始化，而out不用<br>（2）out指定的参数在进入函数时会清空自己，因此必须在函数内部进行初始化赋值操作，而ref不用<br>总结：ref可以把值传到方法里，也可以把值传到方法外；out只可以把值传到方法外<br>注意：string作为特殊的引用类型，其操作是与值类型看齐的，若要将方法内对形参赋值后的结果传递<br>出来，需要加上ref或out关键字。</p>
<h2 id="11-C-中什么是装箱和拆箱？"><a href="#11-C-中什么是装箱和拆箱？" class="headerlink" title="11.C#中什么是装箱和拆箱？"></a>11.C#中什么是装箱和拆箱？</h2><p>装箱：把值类型转换成引用类型<br>拆箱：把引用类型转换成值类型<br>装箱：对值类型在堆中分配一个对象实例，并将该值复制到新的对象中。<br>（1）第一步：新分配托管堆内存(大小为值类型实例大小加上一个方法表指针。<br>（2）第二步：将值类型的实例字段拷贝到新分配的内存中。<br>（3）第三步：返回托管堆中新分配对象的地址。这个地址就是一个指向对象的引用了。<br>拆箱：检查对象实例，确保它是给定值类型的一个装箱值。将该值从实例复制到值类型变量中。<br>在装箱时是不需要显式的类型转换的，不过拆箱需要显式的类型转换。<br>int i&#x3D;0;<br>System.Object obj&#x3D;i; &#x2F;&#x2F;这个过程就是装箱！就是将 i 装箱！<br>int j&#x3D;(int)obj;&#x2F;&#x2F;这个过程 obj 拆箱！</p>
<h2 id="12-C-实现多态的过程中-overload-重载-与override-重写的区别？"><a href="#12-C-实现多态的过程中-overload-重载-与override-重写的区别？" class="headerlink" title="12.C#实现多态的过程中 overload 重载 与override 重写的区别？"></a>12.C#实现多态的过程中 overload 重载 与override 重写的区别？</h2><p>override 重写与 overload 重载的区别。<br>重载是方法的名称相同。参数或参数类型不同，进行多次重载以适应不同的需要<br>override 是进行基类中函数的重写。实现多态。<br>重载：是方法的名称相同，参数或参数类型不同；重载是面向过程的概念。<br>重写：是对基类中的虚方法进行重写。重写是面向对象的概念。</p>
<h2 id="13-C-中static关键字的作用？"><a href="#13-C-中static关键字的作用？" class="headerlink" title="13.C# 中static关键字的作用？"></a>13.C# 中static关键字的作用？</h2><p>对类有意义的字段和方法使用static关键字修饰，称为静态成员，通过类名加访问操作符“.”进行访问; 对<br>类的实例有意义的字段和方法不加static关键字，称为非静态成员或实例成员。<br>注: 静态字段在内存中只有一个拷贝，非静态字段则是在每个实例对象中拥有一个拷贝。而方法无论是否<br>为静态，在内存中只会有一份拷贝，区别只是通过类名来访问还是通过实例名来访问。</p>
<h2 id="14-C-成员变量和成员函数前加static的作用？"><a href="#14-C-成员变量和成员函数前加static的作用？" class="headerlink" title="14.C# 成员变量和成员函数前加static的作用？"></a>14.C# 成员变量和成员函数前加static的作用？</h2><p>它们被称为常成员变量和常成员函数，又称为类成员变量和类成员函数。<br>分别用来反映类的状态。<br>比如类成员变量可以用来统计类实例的数量，类成员函数<br>负责这种统计的动作。不用new</p>
<h2 id="15-C-中索引器的实现过程，是否只能根据数字进行索引，请描述一下"><a href="#15-C-中索引器的实现过程，是否只能根据数字进行索引，请描述一下" class="headerlink" title="15.C#中索引器的实现过程，是否只能根据数字进行索引，请描述一下"></a>15.C#中索引器的实现过程，是否只能根据数字进行索引，请描述一下</h2><p>C#通过提供索引器，可以象处理数组一样处理对象。特别是属性，每一个元素都以一个get或set方法暴<br>露。索引器不单能索引数字（数组下标），还能索引一些HASHMAP的字符串，所以，通常来说，C#中<br>类的索引器通常只有一个，就是THIS，但也可以有无数个，只要你的参数列表不同就可以了索引器和返<br>回值无关, 索引器最大的好处是使代码看上去更自然，更符合实际的思考模式。<br>微软官方一个示例：<br>索引器允许类或结构的实例按照与数组相同的方式进行索引。 索引器类似于属性，不同之处在于它们的<br>访问器采用参数。 在下面的示例中，定义了一个泛型类（class SampleCollection ），并为其提供了简<br>单的 get 和 set访问器 方法（作为分配和检索值的方法）。Program 类为存储字符串创建了此类的一个<br>实例。</p>
<h2 id="16-C-中-abstract-class和interface有什么区别"><a href="#16-C-中-abstract-class和interface有什么区别" class="headerlink" title="16.C#中 abstract class和interface有什么区别?"></a>16.C#中 abstract class和interface有什么区别?</h2><p>abstract class abstract 声明抽象类抽象方法，一个类中有抽象方法，那么这个类就是抽象类了。所谓的<br>抽象方法，就是不含主体（不提供实现方法），必须由继承者重写。因此，抽象类不可实例化，只能通<br>过继承被子类重写。<br>interface 声明接口，只提供一些方法规约，在C#8之前的版本中不提供任何实现，在C#9版本也可以支<br>持接口的实现；不能用public、abstract等修饰，无字段、常量，无构造函数<br>两者区别：<br>1.interface中不能有字段，而abstract class可以有;<br>2.interface中不能有public等修饰符，而abstract class 可以有。<br>3.interface 可以实现多继承。</p>
<h2 id="17-C-中用sealed修饰的类有什么特点？"><a href="#17-C-中用sealed修饰的类有什么特点？" class="headerlink" title="17.C#中用sealed修饰的类有什么特点？"></a>17.C#中用sealed修饰的类有什么特点？</h2><p>密封，不能继承。</p>
<h2 id="18-字符串中string-str-x3D-null和string-str-x3D-””和string-str-x3D-string-Empty的区别"><a href="#18-字符串中string-str-x3D-null和string-str-x3D-””和string-str-x3D-string-Empty的区别" class="headerlink" title="18.字符串中string str&#x3D;null和string str&#x3D;””和string str&#x3D;string.Empty的区别"></a>18.字符串中string str&#x3D;null和string str&#x3D;””和string str&#x3D;string.Empty的区别</h2><p>string.Empty相当于“”,Empty是一个静态只读的字段。 string str&#x3D;”” ,初始化对象，并分配一个空字符串<br>的内存空间 string str&#x3D;null,初始化对象，不会分配内存空间</p>
<h2 id="19-byte-b-x3D-‘a’-byte-c-x3D-1-byte-d-x3D-‘ab’-byte-e-x3D-‘啊’-byte-g-x3D-256-这些变量有些错误是错在哪里"><a href="#19-byte-b-x3D-‘a’-byte-c-x3D-1-byte-d-x3D-‘ab’-byte-e-x3D-‘啊’-byte-g-x3D-256-这些变量有些错误是错在哪里" class="headerlink" title="19.byte b &#x3D; ‘a’; byte c &#x3D; 1; byte d &#x3D; ‘ab’; byte e &#x3D; ‘啊’; byte g &#x3D;256; 这些变量有些错误是错在哪里?"></a>19.byte b &#x3D; ‘a’; byte c &#x3D; 1; byte d &#x3D; ‘ab’; byte e &#x3D; ‘啊’; byte g &#x3D;256; 这些变量有些错误是错在哪里?</h2><p>本题考查的是数据类型能承载数据的大小。<br>1byte &#x3D;8bit，1个汉字&#x3D;2个byte，1个英文&#x3D;1个byte&#x3D;8bit<br>所以bc是对的，deg是错的。’a’是char类型，a错误<br>java byte取值范围是-128<del>127, 而C#里一个byte是0</del>255</p>
<h2 id="20-string和StringBuilder的区别-两者性能的比较"><a href="#20-string和StringBuilder的区别-两者性能的比较" class="headerlink" title="20.string和StringBuilder的区别,两者性能的比较"></a>20.string和StringBuilder的区别,两者性能的比较</h2><p>都是引用类型，分配再堆上<br>StringBuilder默认容量是16，可以允许扩充它所封装的字符串中字符的数量.每个StringBuffer对象都有<br>一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会<br>自动增加容量。<br>对于简单的字符串连接操作，在性能上stringbuilder不一定总是优于strin因为stringbulider对象的创建<br>也消耗大量的性能，在字符串连接比较少的情况下，过度滥用stringbuilder会导致性能的浪费而非节<br>约，只有大量无法预知次数的字符串操作才考虑stringbuilder的使用。从最后分析可以看出如果是相对<br>较少的字符串拼接根本看不出太大差别。<br>Stringbulider的使用，最好制定合适的容量值，否则优于默认值容量不足而频繁的进行内存分</p>
<h2 id="21-什么是扩展方法？"><a href="#21-什么是扩展方法？" class="headerlink" title="21.什么是扩展方法？"></a>21.什么是扩展方法？</h2><p>一句话解释，扩展方法使你能够向现有类型“添加”方法，无需修改类型<br>条件：按扩展方法必须满足的条件，1.必须要静态类中的静态方法2.第一个参数的类型是要扩展的类<br>型，并且需要添加this关键字以标识其为扩展方法<br>建议：通常，只在不得已的情况下才实现扩展方法，并谨慎的实现<br>使用：不能通过类名调用，直接使用类型来调用</p>
<h2 id="22-特性是什么？如何使用？"><a href="#22-特性是什么？如何使用？" class="headerlink" title="22. 特性是什么？如何使用？"></a>22. 特性是什么？如何使用？</h2><p>特性与属性是完全不相同的两个概念，只是在名称上比较相近。Attribute特性就是关联了一个目标对象<br>的一段配置信息，本质上是一个类，其为目标元素提供关联附加信息，这段附加信息存储在dll内的元数<br>据，它本身没什么意义。运行期以反射的方式来获取附加信息</p>
<h2 id="23-什么叫应用程序域-AppDomain"><a href="#23-什么叫应用程序域-AppDomain" class="headerlink" title="23.什么叫应用程序域(AppDomain)"></a>23.什么叫应用程序域(AppDomain)</h2><p>一种边界，它由公共语言运行库围绕同一应用程序范围内创建的对象建立（即，从应用程序入口点开<br>始，沿着对象激活的序列的任何位置）。<br>应用程序域有助于将在一个应用程序中创建的对象与在其他应用程序中创建的对象隔离，以使运行时行<br>为可以预知。<br>在一个单独的进程中可以存在多个应用程序域。应用程序域可以理解为一种轻量级进程。起到安全的作<br>用。占用资源小。</p>
<h2 id="24-byte-a-x3D-255-a-x3D-5-a的值是多少？"><a href="#24-byte-a-x3D-255-a-x3D-5-a的值是多少？" class="headerlink" title="24.byte a &#x3D;255;a+&#x3D;5;a的值是多少？"></a>24.byte a &#x3D;255;a+&#x3D;5;a的值是多少？</h2><p>byte的取值范围是-2的8次方至2的8次方-1，-256至258，a+&#x3D;1时，a的值时0，a+&#x3D;5时，a的值是0，所<br>以a+&#x3D;5时，值是4</p>
<h2 id="25-const和readonly有什么区别？"><a href="#25-const和readonly有什么区别？" class="headerlink" title="25.const和readonly有什么区别？"></a>25.const和readonly有什么区别？</h2><p>都可以标识一个常量。主要有以下区别：<br>1、初始化位置不同。const必须在声明的同时赋值；readonly即可以在声明处赋值;<br>2、修饰对象不同。const即可以修饰类的字段，也可以修饰局部变量；readonly只能修饰类的字段<br>3、const是编译时常量，在编译时确定该值；readonly是运行时常量，在运行时确定该值。<br>4、const默认是静态的；而readonly如果设置成静态需要显示声明<br>5、修饰引用类型时不同，const只能修饰string或值为null的其他引用类型；readonly可以是任何类型。</p>
<h2 id="26-分析下面代码，a、b的值是多少？"><a href="#26-分析下面代码，a、b的值是多少？" class="headerlink" title="26.分析下面代码，a、b的值是多少？"></a>26.分析下面代码，a、b的值是多少？</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> strTmp = <span class="string">&quot;a1某某某&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> a = System.Text.Encoding.Default.GetBytes(strTmp).Length;</span><br><span class="line"><span class="built_in">int</span> b = strTmp.Length;</span><br></pre></td></tr></table></figure>
<p>分析：一个字母、数字占一个byte，一个中文占占两个byte，所以a&#x3D;8,b&#x3D;5</p>
<h2 id="27-String-s-x3D-new-String-“xyz”-创建了几个String-Object"><a href="#27-String-s-x3D-new-String-“xyz”-创建了几个String-Object" class="headerlink" title="27.String s &#x3D; new String(“xyz”);创建了几个String Object?"></a>27.String s &#x3D; new String(“xyz”);创建了几个String Object?</h2><p>两个对象，一个是“xyz”,一个是指向“xyz”的引用对象s。</p>
<h2 id="28-c-可否对内存直接操作"><a href="#28-c-可否对内存直接操作" class="headerlink" title="28.c#可否对内存直接操作"></a>28.c#可否对内存直接操作</h2><p>C#在unsafe 模式下可以使用指针对内存进行操作, 但在托管模式下不可以使用指针，C#NET默认不运行<br>带指针的，需要设置下，选择项目右键-&gt;属性-&gt;选择生成-&gt;“允许不安全代码”打勾-&gt;保存</p>
<h2 id="29-什么是强类型，什么是弱类型？哪种更好些？为什么"><a href="#29-什么是强类型，什么是弱类型？哪种更好些？为什么" class="headerlink" title="29.什么是强类型，什么是弱类型？哪种更好些？为什么?"></a>29.什么是强类型，什么是弱类型？哪种更好些？为什么?</h2><p>强类型是在编译的时候就确定类型的数据，在执行时类型不能更改，而弱类型在执行的时候才会确定类<br>型。没有好不好，二者各有好处，强类型安全，因为它事先已经确定好了，而且效率高。一般用于编译<br>型编程语言，如c++,java,c#,pascal等,弱类型相比而言不安全，在运行的时候容易出现错误，但它灵活，<br>多用于解释型编程语言，如javascript等</p>
<h2 id="30-Math-Round-11-5-等于多少-Math-Round-11-5-等于多少"><a href="#30-Math-Round-11-5-等于多少-Math-Round-11-5-等于多少" class="headerlink" title="30.Math.Round(11.5)等于多少? Math.Round(-11.5)等于多少?"></a>30.Math.Round(11.5)等于多少? Math.Round(-11.5)等于多少?</h2><p>Math.Round(11.5)&#x3D;12<br>Math.Round(-11.5)&#x3D;-12</p>
<h2 id="31-amp-和-amp-amp-的区别"><a href="#31-amp-和-amp-amp-的区别" class="headerlink" title="31.&amp;和&amp;&amp;的区别"></a>31.&amp;和&amp;&amp;的区别</h2><p><strong>相同点</strong><br>&amp;和&amp;&amp;都可作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，其结<br>果才为true，否则，只要有一方为false，则结果为false。（ps：当要用到逻辑与的时候&amp;是毫无意义，<br>&amp;本身就不是干这个的）<br>string strTmp &#x3D; “a1某某某”;<br>int a &#x3D; System.Text.Encoding.Default.GetBytes(strTmp).Length;<br>int b &#x3D; strTmp.Length;<br><strong>不同点</strong><br>if(loginUser!&#x3D;null&amp;&amp;string.IsnullOrEmpty(loginUser.UserName))<br>&amp;&amp;具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式，对于上面的表达式，当<br>loginUser为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&amp;&amp;改为&amp;，则<br>会抛出NullPointerException异常。（ps：所以说当要用到逻辑与的时候&amp;是毫无意义的）<br>&amp; 是用作位运算的。<br><strong>总结</strong><br>&amp;是位运算，返回结果是int类型 &amp;&amp;是逻辑运算，返回结果是bool类型</p>
<h2 id="32-i-和-i有什么区别？"><a href="#32-i-和-i有什么区别？" class="headerlink" title="32.i++和++i有什么区别？"></a>32.i++和++i有什么区别？</h2><p>1.i++是先赋值，然后再自增；++i是先自增，后赋值。<br>2.i&#x3D;0，i++&#x3D;0，++i&#x3D;1； Console.WriteLine(++i&#x3D;&#x3D;i++); 结果位true</p>
<h2 id="33-as和is的区别"><a href="#33-as和is的区别" class="headerlink" title="33.as和is的区别"></a>33.as和is的区别</h2><p>as在转换的同时判断兼容性，如果无法进行转换，返回位null（没有产生新的对象），as转换是否成功<br>判断的依据是是否位null is只是做类型兼容性判断，并不执行真正的类型转换，返回true或false，对象<br>为null也会返回false。<br>as比is效率更高，as只需要做一次类型兼容检查</p>
<h2 id="34-谈谈final、finally的区别。"><a href="#34-谈谈final、finally的区别。" class="headerlink" title="34.谈谈final、finally的区别。"></a>34.谈谈final、finally的区别。</h2><p>final：不能作为父类被继承。一个类不能声明是final，又声明为abstract。<br>finally：用于try{}catch{}finally{}结构，用于异常处理时执行任何清除操作。</p>
<h2 id="35-简述C-成员修饰符"><a href="#35-简述C-成员修饰符" class="headerlink" title="35.简述C#成员修饰符"></a>35.简述C#成员修饰符</h2><p>abstract:指示该方法或属性没有实现。<br>const:指定域或局部变量的值不能被改动。<br>event:声明一个事件。<br>extern:指示方法在外部实现。<br>override:对由基类继承成员的新实现。<br>readonly:指示一个域只能在声明时以及相同类的内部被赋值。<br>static:指示一个成员属于类型本身,而不是属于特定的对象。<br>virtual:指示一个方法或存取器的实现可以在继承类中被覆盖。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="36-什么是匿名类，有什么好处？"><a href="#36-什么是匿名类，有什么好处？" class="headerlink" title="36.什么是匿名类，有什么好处？"></a>36.什么是匿名类，有什么好处？</h2><p>不用定义、没有名字的类，使用一次便可丢弃。好处是简单、随意、临时的。</p>
<h2 id="37-说说什么是逐字字符串"><a href="#37-说说什么是逐字字符串" class="headerlink" title="37.说说什么是逐字字符串"></a>37.说说什么是逐字字符串</h2><p>在普通字符串中，反斜杠字符是转义字符。而在逐字字符串（Verbatim Strings）中，字符将被编程器<br>按照原义进行解释。使用逐字字符串只需在字符串前面加上 @ 符号。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逐字字符串：转义符</span></span><br><span class="line"><span class="keyword">var</span> filename = <span class="string">@&quot;c:\temp\newfile.txt&quot;</span>;</span><br><span class="line">Console.WriteLine(filenaame);</span><br><span class="line"><span class="comment">// 逐字字符串：多行文本</span></span><br><span class="line"><span class="keyword">var</span> multiLine = <span class="string">@&quot;This is a</span></span><br><span class="line"><span class="string">multiline paragraph.&quot;</span>;</span><br><span class="line">Console.WriteLine(multiLine);</span><br><span class="line"><span class="comment">// 非逐字字符串</span></span><br><span class="line"><span class="keyword">var</span> escapedFilename = <span class="string">&quot;c:\temp\newfile.txt&quot;</span>;</span><br><span class="line">Console.WriteLine(escapedFilename);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c:\temp\newfile.txt</span><br><span class="line">This <span class="keyword">is</span> a</span><br><span class="line">multiline paragraph.</span><br><span class="line">c: emp</span><br><span class="line">ewfile.txt</span><br></pre></td></tr></table></figure>
<p>逐字字符串中唯一不被原样解释的字符是双引号。由于双引号是定义字符串的关键字符，所以在逐字字<br>符串中要表达双引号需要用双引号进行转义。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">@&quot;&quot;&quot;I don&#x27;t think so&quot;&quot;, he said.&quot;</span>;</span><br><span class="line">Console.WriteLine(str);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;I don&#x27;t think so&quot;</span>, he said.</span><br></pre></td></tr></table></figure>


<h2 id="38-列举你知道的数字格式化转换"><a href="#38-列举你知道的数字格式化转换" class="headerlink" title="38.列举你知道的数字格式化转换"></a>38.列举你知道的数字格式化转换</h2><p>可使用“0”和“#”占位符进行补位。“0” 表示位数不够位数就补充“0”，小数部分如果位数多了则会四舍五<br>入；“#”表示占位，用于辅助“0”进行补位。如下例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// “0”描述：占位符，如果可能，填充位</span></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0:000000&#125;&quot;</span>, <span class="number">1234</span>)); <span class="comment">// 结果：001234</span></span><br><span class="line"><span class="comment">// “#”描述：占位符，如果可能，填充位</span></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0:######&#125;&quot;</span>, <span class="number">1234</span>)); <span class="comment">// 结果：1234</span></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0:#0####&#125;&quot;</span>, <span class="number">1234</span>)); <span class="comment">// 结果：01234</span></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0:0#0####&#125;&quot;</span>, <span class="number">1234</span>)); <span class="comment">// 结果：</span></span><br><span class="line"><span class="number">0001234</span></span><br><span class="line">内置快捷字母格式化用法</span><br><span class="line">ToString 也可以自定义补零格式化：</span><br><span class="line"><span class="comment">// &quot;.&quot;描述：小数点</span></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0:000.000&#125;&quot;</span>, <span class="number">1234</span>)); <span class="comment">// 结果：</span></span><br><span class="line"><span class="number">1234.000</span></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0:000.000&#125;&quot;</span>, <span class="number">4321.12543</span>)); <span class="comment">// 结果：</span></span><br><span class="line"><span class="number">4321.125</span></span><br><span class="line"><span class="comment">// &quot;,&quot;描述：千分表示</span></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0:0,0&#125;&quot;</span>, <span class="number">1234567</span>)); <span class="comment">//结果：</span></span><br><span class="line"><span class="number">1</span>,<span class="number">234</span>,<span class="number">567</span></span><br><span class="line"><span class="comment">// &quot;%&quot;描述：格式化为百分数</span></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0:0%&#125;&quot;</span>, <span class="number">1234</span>)); <span class="comment">// 结果：</span></span><br><span class="line"><span class="number">123400</span>%</span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0:#%&#125;&quot;</span>, <span class="number">1234.125</span>)); <span class="comment">// 结果：</span></span><br><span class="line"><span class="number">123413</span>%</span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0:0.00%&#125;&quot;</span>, <span class="number">1234</span>)); <span class="comment">// 结果：</span></span><br><span class="line"><span class="number">123400.00</span>%</span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0:#.00%&#125;&quot;</span>, <span class="number">1234.125</span>)); <span class="comment">// 结果：</span></span><br><span class="line"><span class="number">123412.50</span>%</span><br></pre></td></tr></table></figure>
<p>内置快捷字母格式化用法</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// E-科学计数法表示</span></span><br><span class="line">Console.WriteLine((<span class="number">25000</span>).ToString(<span class="string">&quot;E&quot;</span>)); <span class="comment">// 结果：2.500000E+004</span></span><br><span class="line"><span class="comment">// C-货币表示，带有逗号分隔符，默认小数点后保留两位，四舍五入</span></span><br><span class="line">Console.WriteLine((<span class="number">2.5</span>).ToString(<span class="string">&quot;C&quot;</span>)); <span class="comment">// 结果：￥2.50</span></span><br><span class="line"><span class="comment">// D[length]-十进制数</span></span><br><span class="line">Console.WriteLine((<span class="number">25</span>).ToString(<span class="string">&quot;D5&quot;</span>)); <span class="comment">// 结果：00025</span></span><br><span class="line"><span class="comment">// F[precision]-浮点数，保留小数位数(四舍五入)</span></span><br><span class="line">Console.WriteLine((<span class="number">25</span>).ToString(<span class="string">&quot;F2&quot;</span>)); <span class="comment">// 结果：25.00</span></span><br><span class="line"><span class="comment">// G[digits]-常规，保留指定位数的有效数字，四舍五入</span></span><br><span class="line">Console.WriteLine((<span class="number">2.52</span>).ToString(<span class="string">&quot;G2&quot;</span>)); <span class="comment">// 结果：2.5</span></span><br><span class="line"><span class="comment">// N-带有逗号分隔符，默认小数点后保留两位，四舍五入</span></span><br><span class="line">Console.WriteLine((<span class="number">2500000</span>).ToString(<span class="string">&quot;N&quot;</span>)); <span class="comment">// 结果：2,500,000.00</span></span><br><span class="line"><span class="comment">// X-十六进制，非整型将产生格式异常</span></span><br><span class="line">Console.WriteLine((<span class="number">255</span>).ToString(<span class="string">&quot;X&quot;</span>)); <span class="comment">// 结果</span></span><br></pre></td></tr></table></figure>
<p>ToString 也可以自定义补零格式化：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine((<span class="number">15</span>).ToString(<span class="string">&quot;000&quot;</span>)); <span class="comment">// 结果：015</span></span><br><span class="line">Console.WriteLine((<span class="number">15</span>).ToString(<span class="string">&quot;value is 0&quot;</span>)); <span class="comment">// 结果：value</span></span><br><span class="line"><span class="keyword">is</span> <span class="number">15</span></span><br><span class="line">Console.WriteLine((<span class="number">10.456</span>).ToString(<span class="string">&quot;0.00&quot;</span>)); <span class="comment">// 结果：10.46</span></span><br><span class="line">Console.WriteLine((<span class="number">10.456</span>).ToString(<span class="string">&quot;00&quot;</span>)); <span class="comment">// 结果：10</span></span><br><span class="line">Console.WriteLine((<span class="number">10.456</span>).ToString(<span class="string">&quot;value is 0.0&quot;</span>)); <span class="comment">// 结果：value</span></span><br><span class="line"><span class="keyword">is</span> <span class="number">10.5</span></span><br></pre></td></tr></table></figure>


<h2 id="39-说说字符串拼接、字符串内插法"><a href="#39-说说字符串拼接、字符串内插法" class="headerlink" title="39.说说字符串拼接、字符串内插法"></a>39.说说字符串拼接、字符串内插法</h2><p>将数组中的字符串拼接成一个字符串：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parts = <span class="keyword">new</span>[] &#123; <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;Bar&quot;</span>, <span class="string">&quot;Fizz&quot;</span>, <span class="string">&quot;Buzz&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> joined = <span class="built_in">string</span>.Join(<span class="string">&quot;, &quot;</span>, parts);</span><br><span class="line"><span class="comment">// joined = &quot;Foo, Bar, Fizz, Buzz&quot;</span></span><br></pre></td></tr></table></figure>
<p>以下四种方式都可以达到相同的字符串拼接的目的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> first = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">stringsecond = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> foo = first + <span class="string">&quot; &quot;</span> + second;</span><br><span class="line"><span class="built_in">string</span> foo = <span class="built_in">string</span>.Concat(first, <span class="string">&quot; &quot;</span>, second);</span><br><span class="line"><span class="built_in">string</span> foo = <span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, firstname, lastname);</span><br><span class="line"><span class="built_in">string</span> foo = <span class="string">$&quot;<span class="subst">&#123;firstname&#125;</span> <span class="subst">&#123;lastname&#125;</span>&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>字符串内插法简单用法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> str =<span class="string">$&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>;</span><br><span class="line"><span class="comment">// str = &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure>
<p>带日期格式化</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date = DateTime.Now;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">$&quot;Today is <span class="subst">&#123;date:yyyy-MM-dd&#125;</span>！&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>补齐格式化（Padding）：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">42</span>;</span><br><span class="line"><span class="comment">// 向左补齐</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">$&quot;The answer to life, the universe and everything is</span></span><br><span class="line"><span class="string"><span class="subst">&#123;number,<span class="number">5</span>&#125;</span>.&quot;</span>;</span><br><span class="line"><span class="comment">// str = &quot;The answer to life, the universe and everything is ___42.&quot;</span></span><br><span class="line">(<span class="string">&#x27;_&#x27;</span>表示空格)</span><br><span class="line"><span class="comment">// 向右补齐</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">$&quot;The answer to life, the universe and everything is</span></span><br><span class="line"><span class="string">$<span class="subst">&#123;number,<span class="number">-5</span>&#125;</span>.&quot;</span>;</span><br><span class="line"><span class="comment">// str = &quot;The answer to life, the universe and everything is 42___.&quot;</span></span><br></pre></td></tr></table></figure>
<p>结合内置快捷字母格式化：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> amount = <span class="number">2.5</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">$&quot;It costs <span class="subst">&#123;amount:C&#125;</span>&quot;</span>;</span><br><span class="line"><span class="comment">// str = &quot;￥2.50&quot;</span></span><br><span class="line"><span class="keyword">var</span> number = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">$&quot;The answer to life, the universe and everything is</span></span><br><span class="line"><span class="string"><span class="subst">&#123;number,<span class="number">5</span>:f1&#125;</span>.&quot;</span>;</span><br><span class="line"><span class="comment">// str = &quot;The answer to life, the universe and everything is</span></span><br><span class="line">___42<span class="number">.1</span><span class="string">&quot;</span></span><br></pre></td></tr></table></figure>


<h2 id="40-什么是虚函数？什么是抽象函数？"><a href="#40-什么是虚函数？什么是抽象函数？" class="headerlink" title="40.什么是虚函数？什么是抽象函数？"></a>40.什么是虚函数？什么是抽象函数？</h2><p>虚函数：没有实现的，可以由子类继承并重写的函数。<br>抽象函数：规定其非虚子类必须实现的函数，必须被重写。</p>
<h2 id="41-什么是WebService"><a href="#41-什么是WebService" class="headerlink" title="41.什么是WebService?"></a>41.什么是WebService?</h2><p>Web Service是基于网络的、分布式的模块化组件，它执行特定的任务，遵守具体的技术规范，这些<br>规范使得Web Service能与其他兼容的组件进行互操作。</p>
<h2 id="42-ADO-NET常用对象有哪些？"><a href="#42-ADO-NET常用对象有哪些？" class="headerlink" title="42.ADO.NET常用对象有哪些？"></a>42.ADO.NET常用对象有哪些？</h2><p>Connection：主要是开启程序和数据库之间的连接。没有利用连接对象将数据库打开，是无法从数据<br>库中取得数据的。Close和Dispose的区别，Close以后还可以Open，Dispose以后则不能再用。<br>Command：主要可以用来对数据库发出一些指令，例如可以对数据库下达查询、新增、修改、删除数<br>据等指令，以及调用存在数据库中的存储过程等。这个对象是架构在Connection 对象上，也就是<br>Command： 对象是通过在Connection对象连接到数据源。<br>DataAdapter：主要是在数据源以及DataSet 之间执行数据传输的工作，它可以透过Command 对象下<br>达命令后，并将取得的数据放入DataSet 对象中。这个对象是架构在Command对象上，并提供了许多<br>配合DataSet 使用的功能。<br>DataSet：这个对象可以视为一个暂存区（Cache），可以把从数据库中所查询到的数据保留起来，甚<br>至可以将整个数据库显示出来，DataSet是放在内存中的。DataSet 的能力不只是可以储存多个Table 而<br>已，还可以透过DataAdapter对象取得一些例如主键等的数据表结构，并可以记录数据表间的关联。<br>DataSet 对象可以说是ADO.NET 中重量级的对象，这个对象架构在DataAdapter对象上，本身不具备和<br>数据源沟通的能力；也就是说我们是将DataAdapter对象当做DataSet 对象以及数据源间传输数据的桥<br>梁。DataSet包含若干DataTable、DataTableTable包含若干DataRow。<br>DataReader：当我们只需要循序的读取数据而不需要其它操作时，可以使用DataReader 对象。<br>DataReader对象只是一次一次向下循序的读取数据源中的数据，这些数据是存在数据库服务器中的，而<br>不是一次性加载到程序的内存中的，只能（通过游标）读取当前行的数据，而且这些数据是只读的，并<br>不允许作其它的操作。因为DataReader 在读取数据的时候限制了每次只读取一条，而且只能只读，所<br>以使用起来不但节省资源而且效率很好。使用DataReader 对象除了效率较好之外，因为不用把数据全<br>部传回，故可以降低网络的负载。</p>
<h2 id="43-在ASP-NET中所有的自定义用户控件都必须继承自？"><a href="#43-在ASP-NET中所有的自定义用户控件都必须继承自？" class="headerlink" title="43.在ASP.NET中所有的自定义用户控件都必须继承自？"></a>43.在ASP.NET中所有的自定义用户控件都必须继承自？</h2><p>Control类</p>
<h2 id="44-在-NET托管代码总我们不必担心内存泄漏，这是因为有了？"><a href="#44-在-NET托管代码总我们不必担心内存泄漏，这是因为有了？" class="headerlink" title="44.在.NET托管代码总我们不必担心内存泄漏，这是因为有了？"></a>44.在.NET托管代码总我们不必担心内存泄漏，这是因为有了？</h2><p>GC 垃圾收集器。</p>
<h2 id="45-什么是MVC模式"><a href="#45-什么是MVC模式" class="headerlink" title="45.什么是MVC模式"></a>45.什么是MVC模式</h2><p>MVC(Model View Controller)模型－视图－控制器<br>aspx就是View，视图；Model：DataSet、Reader、对象；Controller：cs代码。<br>MVC是典型的平行关系，没有说谁在上谁在下的关系，模型负责业务领域的事情，视图负责显示的事<br>情，控制器把数据读取出来填充模型后把模型交给视图去处理。而各种验证什么的应该是在模型里处理<br>了。它强制性的使应用程序的输入、处理和输出分开。MVC最大的好处是将逻辑和页面分离。</p>
<h2 id="46-能用foreach遍历访问的对象的要求"><a href="#46-能用foreach遍历访问的对象的要求" class="headerlink" title="46.能用foreach遍历访问的对象的要求"></a>46.能用foreach遍历访问的对象的要求</h2><p>需要实现IEnumerable接口或声明GetEnumerator方法的类型。</p>
<h2 id="47-什么是反射"><a href="#47-什么是反射" class="headerlink" title="47.什么是反射?"></a>47.什么是反射?</h2><p>程序集包含模块，而模块又包括类型，类型下有成员，反射就是管理程序集，模块，类型的对象，它能<br>够动态的创建类型的实例，设置现有对象的类型或者获取现有对象的类型，能调用类型的方法和访问类<br>型的字段属性。它是在运行时创建和使用类型实例。</p>
<h2 id="48-ORM中的延迟加载与直接加载有什么异同？"><a href="#48-ORM中的延迟加载与直接加载有什么异同？" class="headerlink" title="48.ORM中的延迟加载与直接加载有什么异同？"></a>48.ORM中的延迟加载与直接加载有什么异同？</h2><p>延迟加载（Lazy Loading）只在真正需要进行数据操作的时候再进行加载数据，可以减少不必要的开销。</p>
<h2 id="49-简述Func与Action的区别？"><a href="#49-简述Func与Action的区别？" class="headerlink" title="49.简述Func与Action的区别？"></a>49.简述Func与Action的区别？</h2><p>Func是有返回值的委托，Action是没有返回值的委托。</p>
<h2 id="50-23种设计模式分别叫什么名称，如何分类？"><a href="#50-23种设计模式分别叫什么名称，如何分类？" class="headerlink" title="50.23种设计模式分别叫什么名称，如何分类？"></a>50.23种设计模式分别叫什么名称，如何分类？</h2><p>分三类：<br>创建型，行为型，结构型；</p>
<p>创建型包含：<br>1.单例模式<br>2.工厂模式<br>3.建造者模式<br>4.原型模式<br>5.工厂方法模式</p>
<p>行为型包含：<br>1.策略模式<br>2.模板方法模式<br>3.观察者模式<br>4.迭代子模式<br>5.责任链模式<br>6.命令模式<br>7.备忘录模式<br>8.状态模式<br>9.访问者模式<br>10.中介者模式<br>11.解释器模式</p>
<p>结构型设计模式包含：<br>1.适配器模式<br>2.装饰器模式<br>3.代理模式<br>4.外观模式<br>5.桥接模式<br>6.组合模式<br>7.享元模式</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.zzonn.com/2020/05/19/C#.NET%E9%97%AE%E7%AD%94%20%E5%9F%BA%E7%A1%80%E7%AF%87-cnet-wen-da-ji-chu-pian/" data-id="clf0jcv6n00066ocxbu921ooi" data-title="C#.NET问答 基础篇" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C#</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-常用Git命令动画演示-常用git命令动画演示" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/17/%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA-%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA/" class="article-date">
  <time class="dt-published" datetime="2020-05-17T09:10:07.000Z" itemprop="datePublished">2020-05-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Git/">Git</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/17/%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA-%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA/">常用Git命令动画演示</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然 Git 是一个强大的工具，但是我觉得大部分人用起来都会认为很复杂，还容易犯错！<br>当我执行某个命令的时候，分支之间是如何交互的？又是如何影响提交历史的？<br>当我在master分支执行hard reset、force push到 origin、在.git文件夹执行rimraf的时候，为什么我的同事都哭了？</p>
<p>我认为创建一些最常见、最实用的命令的可视化示例是最佳使用指南！接下来介绍的这些命令，很多都有可选参数，用于改变命令的行为。文中的示例只讨论命令的默认行为，不会涉及太多的配置选项。这些命令包括 merge，rebase，reset， revert，cherry-pick，fetch，pull，reflog 等。</p>
<h2 id="merge（合并）"><a href="#merge（合并）" class="headerlink" title="merge（合并）"></a>merge（合并）</h2><p>多分支可以非常方便地将新的改动互相隔离，并确保你不会意外地将未经批准或破坏性的变更推到生产环境。一旦变更被批准，我们就能在生产分支中得到这些变更。</p>
<p>从一个分支获取变更到另一个分支的方式之一是执行git merge命令。Git 有两类合并操作：fast-forward 和no-fast-forward。</p>
<p>这么说你可能没什么概念，我们来看看区别吧。</p>
<h3 id="fast-forward-–ff"><a href="#fast-forward-–ff" class="headerlink" title="fast-forward (–ff)"></a>fast-forward (–ff)</h3><p>如果当前分支与即将合并过来的分支相比，没有额外的提交，这种就是fast-forward合并。Git 很会偷懒，它会首先尝试最简单的方案，即fast-forward。这种合并方式不会创建新的提交，只是把另一个分支的提交记录直接合并到当前分支。</p>
<p><img src="https://www.zzonn.com/upload/2021/04/1gif-c017fb0ebcaf41caa688e8c84dde970b.gif" alt="1gif.gif"></p>
<p>现在我们在master分支上有了dev分支上的所有变更。那么，no-fast-forward 又是什么呢？</p>
<h3 id="no-fast-foward-–no-ff"><a href="#no-fast-foward-–no-ff" class="headerlink" title="no-fast-foward (–no-ff)"></a>no-fast-foward (–no-ff)</h3><p>跟即将合并过来的分支比较，当前分支如果没有额外的提交，这固然很好，但实际情况往往不是这样！如果我们在当前分支上也提交了一些改动，那么 Git 就会执行no-fast-forward合并。</p>
<p>对于 no-fast-forward 合并，Git 会在当前分支上创建一个新的合并提交。该提交的父提交同时指向当前分支和合并过来的分支。</p>
<p><img src="https://www.zzonn.com/upload/2021/04/2-2a7f14efbb3c4fe5867a5948cdb936db.gif" alt="2.gif"></p>
<p>现在master分支上有了我们在dev分支上做的所有变更。</p>
<h2 id="Merge-Conflicts-合并冲突"><a href="#Merge-Conflicts-合并冲突" class="headerlink" title="Merge Conflicts(合并冲突)"></a>Merge Conflicts(合并冲突)</h2><p>虽然 Git 擅长决定如何合并分支和更改文件，但它也不是总能自己做出决定。当我们试图合并的两个分支在同一文件的同一行上都有改动时，或者一个分支删除了文件，另一个分支又修改了它，都可能发生这种情况。</p>
<p>这种情况下，Git 会要求你帮助决定要保留哪边的改动。假设在两个分支上，我们都编辑了README.md文件的第一行：</p>
<p><img src="https://www.zzonn.com/upload/2021/04/3-c5b022d918d947ca8dcbedf543da0136.jfif" alt="3.jfif"></p>
<p>如果把dev合并到 master，会导致合并冲突：你是要 Hello! 呢，还是要 Hey! ？</p>
<p>合并分支时，Git 会显示冲突的位置。我们可以手动删除不想保留的改动，然后保存，再添加改动后的文件（git add）并提交。</p>
<p><img src="https://www.zzonn.com/upload/2021/04/4-6df24ddeaed1409a9fa73b41953cb374.gif" alt="4.gif"></p>
<p>合并冲突虽然很烦人，但也是合理的：Git 不应该自作主张保留哪边的改动。</p>
<h2 id="rebase（变基）"><a href="#rebase（变基）" class="headerlink" title="rebase（变基）"></a>rebase（变基）</h2><p>刚刚我们看到了如何通过执行git merge将一个分支的改动应用到另一个分支。另一种方式是使用git rebase。</p>
<p>git rebase命令复制当前分支的提交，然后把这些提交放到指定分支之上。</p>
<p><img src="https://www.zzonn.com/upload/2021/04/5-6800add66389481a962fe3c0de994c6d.gif" alt="5.gif"></p>
<p>现在 master 分支上的所有改动都跑到dev分支上了！</p>
<p>与merge相比，最大的区别是 Git 不会去找出哪些文件需要保留，哪些文件不需要保留。我们要rebase的分支总是包含了我们想要保留的最新改动。这种方式不会有合并冲突，并且保持了良好的线性 Git 历史记录。</p>
<p>这个例子演示了在 master分支上执行rebase。不过，在大项目里你可能不会这么做。git rebase命令会修改项目历史记录，因为复制的提交会产生新的 hash。</p>
<p>当你在特性分支上开发时，master分支有更新的时候，rebase很有用。这样你在当前分支就能拿到所有更新，避免了将来可能的合并冲突。</p>
<h2 id="Interactive-Rebase（交互式变基）"><a href="#Interactive-Rebase（交互式变基）" class="headerlink" title="Interactive Rebase（交互式变基）"></a>Interactive Rebase（交互式变基）</h2><p>在 rebase 之前，我们还可以修改！这是通过交互式 rebase 实现的。交互式 rebase 也可以用于当前正在处理的分支，在希望修改某些提交的时候。<br>对于即将 rebase 的提交，可以执行 6 种操作：</p>
<p>reword：修改提交说明<br>edit：修改提交内容（amend）<br>squash：将该提交合并到前一个提交<br>fixup: 将该提交合并到前一个提交，不保留提交的日志消息<br>exec: 在想要 rebase 的每一个提交上执行命令<br>drop: 删除提交</p>
<p>这样，我们就能完全控制提交记录了。如果想删除某个提交，只要 drop 它就行了。</p>
<p><img src="https://www.zzonn.com/upload/2021/04/6-5bd745c67d8e4fc5a1b9d98c4df4c81a.gif" alt="6.gif"></p>
<p>或者，如果我们想要把多个提交合并到一起，这样历史记录会更清晰，也没问题！</p>
<p>交互式 rebase 给了你对想要 rebase 的提交很多控制权，哪怕是当前的活动分支。</p>
<h2 id="reset（重置）"><a href="#reset（重置）" class="headerlink" title="reset（重置）"></a>reset（重置）</h2><p>有时候我们提交了一些改动，后来又不想要了。有可能是 WIP 提交，也可能是某个引入了 bug 的提交。这种情况，我们可以执行git reset。</p>
<p>git reset会丢弃当前所有暂存的文件，并让我们决定 HEAD 应该指向哪里。</p>
<h3 id="soft-reset"><a href="#soft-reset" class="headerlink" title="soft reset"></a>soft reset</h3><p>soft reset 将HEAD 移动到指定的提交（或者相对于 HEAD 的位置索引），同时不会丢弃这些提交带来的改动。</p>
<p>假设我们不想保留添加了style.css文件的提交 9e78i，也不想保留添加了index.js文件的提交 035cc 。但是，我们却想要保留新增的style.css和index.js文件。这里用 soft reset 就非常合适。</p>
<p><img src="https://www.zzonn.com/upload/2021/04/7-434f489ed603436980ea33a2d7b0dc72.gif" alt="7.gif"></p>
<p>执行git status，你会看到我们依然能够查看之前提交所做的改动。这很有用，因为这样我们就能继续修改文件内容，后续再次提交了。</p>
<h3 id="hard-reset"><a href="#hard-reset" class="headerlink" title="hard reset"></a>hard reset</h3><p>有时候，我们不想保留某些提交带来的改动。跟 soft reset 不一样，我们不再需要访问这些变动了。Git 应该简单地重置到指定的提交，并且会重置工作区和暂存区的文件。</p>
<p><img src="https://www.zzonn.com/upload/2021/04/8-57a2bcd354ea4de4b0124f33eac47eb5.gif" alt="8.gif"></p>
<p>Git 已经丢弃了9e78i 和 035cc 两个提交引起的改动，并把状态重置到了提交ec5be的位置。</p>
<h2 id="revert（回滚）"><a href="#revert（回滚）" class="headerlink" title="revert（回滚）"></a>revert（回滚）</h2><p>撤销改动的另一种方式是执行git revert。复原某个提交后，会创建一个新的提交，包含了恢复后的改动。</p>
<p>假设提交 ec5be 添加了一个index.js文件。随后，我们发现实际上不再需要这个改动了，就可以恢复ec5be这个提交。</p>
<p><img src="https://www.zzonn.com/upload/2021/04/9-f21bd8f163e14b80a2807f48eb107dbc.gif" alt="9.gif"></p>
<p>提交9e78i恢复了 ec5be 这个提交带来的改动。执行 git revert对于撤销某个提交非常有用，同时又不会修改分支的历史。</p>
<h2 id="cherry-pick（提交拣选）"><a href="#cherry-pick（提交拣选）" class="headerlink" title="cherry-pick（提交拣选）"></a>cherry-pick（提交拣选）</h2><p>当活动分支需要某个分支的某个提交包含的改动时，我们可以用cherry-pick命令。通过cherry-pick某个提交，在当前活动分支上会创建一个新提交，包含了前者带来的改动。</p>
<p>假设 dev 分支上的提交76d12改动了index.js文件，我们在master分支上也需要。我们不需要整个分支上的改动，只要这个提交。</p>
<p><img src="https://www.zzonn.com/upload/2021/04/10-b72c2d7ceb134fb3a55a9f3f74a9fe3f.gif" alt="10.gif"></p>
<p>master分支现在也包含了76d12提交的改动了。</p>
<h2 id="fetch（提取-x2F-获取）"><a href="#fetch（提取-x2F-获取）" class="headerlink" title="fetch（提取&#x2F;获取）"></a>fetch（提取&#x2F;获取）</h2><p>如果存在远程分支，远程分支可能有些提交是当前的本地分支没有的。有可能是其他分支合并过去了，或者你的同事推送了某些改动，等等。</p>
<p>我们可以用git fetch 把这些改动获取到本地。这不会影响本地分支，fetch 只是下载数据。</p>
<p><img src="https://www.zzonn.com/upload/2021/04/11-db0717d9897d4d88a8ca8e3d9acc3b70.gif" alt="11.gif"></p>
<p>现在就可以看到从最近一次推送以来的所有变动。本地有了这些新数据，我们就可以决定如何使用了。</p>
<h2 id="pull-（拉取）"><a href="#pull-（拉取）" class="headerlink" title="pull （拉取）"></a>pull （拉取）</h2><p>除了用git fetch 获取远程分支信息外，还可以用git pull。git pull实际上是两个命令合而为一：git fetch和git merge。当我们从 origin 拉取改动时，先是像git fetch一样获取所有数据，然后最新改动会自动合并到本地分支。</p>
<p><img src="https://www.zzonn.com/upload/2021/04/12-0f786768b77841308004aee9690568ca.gif" alt="12.gif"></p>
<p>这样就跟远程分支保持同步了，包含了所有的最新改动。</p>
<h2 id="reflog-（操作日志）"><a href="#reflog-（操作日志）" class="headerlink" title="reflog （操作日志）"></a>reflog （操作日志）</h2><p>每个人都会犯错误，这完全没有关系！有时候你可能觉得自己把仓库搞得一团糟，只想把它删了完事。</p>
<p>git reflog是个非常有用的命令，可以显示所有操作的日志。包括 merge，reset，revert 等，基本上包括了对分支的任何更改。</p>
<p><img src="https://www.zzonn.com/upload/2021/04/13-8808acbd57c34d25a61ae0bdd7df1b21.gif" alt="13.gif"></p>
<p>如果出错了，你可以根据reflog提供的信息通过重置 HEAD 来撤销改动。</p>
<p>比如，我们实际上并不想合并分支。当我们执行 git reflog 命令时，我们看到在合并前仓库位于HEAD@{1}。我们执行下git reset命令，让 HEAD 重新指回原来的HEAD@{1} 位置。</p>
<p><img src="https://www.zzonn.com/upload/2021/04/14-e3cec92c29cc4defa1556381d3b51ea8.gif" alt="14.gif"></p>
<p>我们可以看到，最新的操作也记录到 reflog 里了。</p>
<p>Git 还有很多有用的命令，篇幅所限不能一一列举。希望通过上面这些形象的动画演示，能够更好地理解这些分支操作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.zzonn.com/2020/05/17/%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA-%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA/" data-id="clf0jcv77001z6ocx1tz51l92" data-title="常用Git命令动画演示" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/" rel="tag">Git</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-docker-compose常用命令-docker-compose常用命令" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/15/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="article-date">
  <time class="dt-published" datetime="2020-04-15T07:35:33.000Z" itemprop="datePublished">2020-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Docker/">Docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/15/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">docker-compose常用命令</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="Docker-compose命令格式"><a href="#Docker-compose命令格式" class="headerlink" title="Docker-compose命令格式"></a>Docker-compose命令格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose [-f &lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure>


<p>命令选项如下</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-f --file FILE指定Compose模板文件，默认为docker-compose.yml</span><br><span class="line">-p --project-name NAME 指定项目名称，默认使用当前所在目录为项目名</span><br><span class="line">--verbose 输出更多调试信息</span><br><span class="line">-v，-version 打印版本并退出</span><br><span class="line">--log-level LEVEL 定义日志等级(DEBUG<span class="punctuation">,</span> INFO<span class="punctuation">,</span> WARNING<span class="punctuation">,</span> ERROR<span class="punctuation">,</span> CRITICAL)</span><br></pre></td></tr></table></figure>


<h4 id="docker-compose-up"><a href="#docker-compose-up" class="headerlink" title="docker-compose up"></a>docker-compose up</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up [options] [--scale SERVICE=NUM...] [SERVICE...]</span><br><span class="line">选项包括：</span><br><span class="line">-d 在后台运行服务容器</span><br><span class="line">-no-color 不是有颜色来区分不同的服务的控制输出</span><br><span class="line">-no-deps 不启动服务所链接的容器</span><br><span class="line">--force-recreate 强制重新创建容器，不能与-no-recreate同时使用</span><br><span class="line">–no-recreate 如果容器已经存在，则不重新创建，不能与–force-recreate同时使用</span><br><span class="line">–no-build 不自动构建缺失的服务镜像</span><br><span class="line">–build 在启动容器前构建服务镜像</span><br><span class="line">–abort-on-container-exit 停止所有容器，如果任何一个容器被停止，不能与-d同时使用</span><br><span class="line">-t, –timeout TIMEOUT 停止容器时候的超时（默认为10秒）</span><br><span class="line">–remove-orphans 删除服务中没有在compose文件中定义的容器</span><br></pre></td></tr></table></figure>
<h4 id="docker-compose-ps"><a href="#docker-compose-ps" class="headerlink" title="docker-compose ps"></a>docker-compose ps</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps [options] [SERVICE...] 列出项目中所有的容器</span><br></pre></td></tr></table></figure>


<h4 id="docker-compose-stop"><a href="#docker-compose-stop" class="headerlink" title="docker-compose stop"></a>docker-compose stop</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop [options] [SERVICE...]</span><br><span class="line">选项包括</span><br><span class="line">-t, –timeout TIMEOUT 停止容器时候的超时（默认为10秒）</span><br><span class="line">docker-compose stop 停止正在运行的容器，可以通过docker-compose start 再次启动</span><br></pre></td></tr></table></figure>


<h4 id="docker-compose-h"><a href="#docker-compose-h" class="headerlink" title="docker-compose -h"></a>docker-compose -h</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -h 查看帮助</span><br></pre></td></tr></table></figure>


<h4 id="docker-compose-down"><a href="#docker-compose-down" class="headerlink" title="docker-compose down"></a>docker-compose down</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down [options]</span><br><span class="line">停止和删除容器、网络、卷、镜像。</span><br><span class="line">选项包括：</span><br><span class="line">–rmi ``type``，删除镜像，类型必须是：all，删除compose文件中定义的所有镜像；local，删除镜像名为空的镜像</span><br><span class="line">-v, –volumes，删除已经在compose文件中定义的和匿名的附在容器上的数据卷</span><br><span class="line">–remove-orphans，删除服务中没有在compose中定义的容器</span><br><span class="line">docker-compose down 停用移除所有容器以及网络相关</span><br></pre></td></tr></table></figure>


<h4 id="docker-compose-logs"><a href="#docker-compose-logs" class="headerlink" title="docker-compose logs"></a>docker-compose logs</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs [options] [SERVICE...] </span><br><span class="line">查看服务容器的输出。默认情况下，docker-compose将对不同的服务输出使用不同的颜色来区分。可以通过–no-color来关闭颜色。</span><br><span class="line">docker-compose logs 查看服务容器的输出</span><br><span class="line">-f 跟踪日志输出</span><br></pre></td></tr></table></figure>


<h4 id="docker-compose-bulid"><a href="#docker-compose-bulid" class="headerlink" title="docker-compose bulid"></a>docker-compose bulid</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker-compose build [options] [--build-arg key=val...] [SERVICE...]</span><br><span class="line">构建（重新构建）项目中的服务容器。</span><br><span class="line">选项包括：</span><br><span class="line">–compress 通过``gzip``压缩构建上下环境</span><br><span class="line">–force-rm 删除构建过程中的临时容器</span><br><span class="line">–no-cache 构建镜像过程中不使用缓存</span><br><span class="line">–pull 始终尝试通过拉取操作来获取更新版本的镜像</span><br><span class="line">-m, –memory MEM为构建的容器设置内存大小</span><br><span class="line">–build-arg key=val为服务设置build-time变量</span><br><span class="line">服务容器一旦构建后，将会带上一个标记名。可以随时在项目目录下运行docker-compose build来重新构建服务</span><br></pre></td></tr></table></figure>


<h4 id="docker-compose-pull"><a href="#docker-compose-pull" class="headerlink" title="docker-compose pull"></a>docker-compose pull</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker-compose pull [options] [SERVICE...] 拉取服务依赖的镜像。</span><br><span class="line">选项包括：</span><br><span class="line">–ignore-pull-failures，忽略拉取镜像过程中的错误</span><br><span class="line">–parallel，多个镜像同时拉取``–quiet，拉取镜像过程中不打印进度信息</span><br><span class="line">docker-compose pull``拉取服务依赖的镜像</span><br></pre></td></tr></table></figure>


<h4 id="docker-compose-restart"><a href="#docker-compose-restart" class="headerlink" title="docker-compose restart"></a>docker-compose restart</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker-compose restart [options] [SERVICE...] 重启项目中的服务。</span><br><span class="line">选项包括：</span><br><span class="line">-t, –timeout TIMEOUT，指定重启前停止容器的超时（默认为10秒）</span><br><span class="line">docker-compose restart 重启项目中的服务</span><br></pre></td></tr></table></figure>


<h4 id="docker-compose-rm"><a href="#docker-compose-rm" class="headerlink" title="docker-compose rm"></a>docker-compose rm</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker-compose rm [options] [SERVICE...] 删除所有（停止状态的）服务容器。</span><br><span class="line">选项包括：</span><br><span class="line">–f, –force，强制直接删除，包括非停止状态的容器</span><br><span class="line">-v，删除容器所挂载的数据卷 </span><br><span class="line">docker-compose rm删除所有（停止状态的）服务容器。推荐先执行docker-compose stop命令来停止容器。</span><br></pre></td></tr></table></figure>


<h4 id="docker-compose-start"><a href="#docker-compose-start" class="headerlink" title="docker-compose start"></a>docker-compose start</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose start [SERVICE...] </span><br><span class="line">docker-compose start </span><br><span class="line">启动已经存在的服务容器。</span><br></pre></td></tr></table></figure>


<h4 id="docker-compose-run"><a href="#docker-compose-run" class="headerlink" title="docker-compose run"></a>docker-compose run</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker-compose run [options] [-v VOLUME...] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</span><br><span class="line">在指定服务上执行一个命令。</span><br><span class="line">docker-compose run ubuntu ping www.baidu.com </span><br><span class="line">在指定容器上执行一个ping命令。</span><br></pre></td></tr></table></figure>


<h4 id="docker-compose-scale"><a href="#docker-compose-scale" class="headerlink" title="docker-compose scale"></a>docker-compose scale</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose scale web=3 db=2 设置指定服务运行的容器个数。通过service=num的参数来设置数量</span><br></pre></td></tr></table></figure>


<h4 id="docker-compose-pause"><a href="#docker-compose-pause" class="headerlink" title="docker-compose pause"></a>docker-compose pause</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose pause [SERVICE...] 暂停一个服务容器</span><br></pre></td></tr></table></figure>


<h4 id="docker-compose-kill"><a href="#docker-compose-kill" class="headerlink" title="docker-compose kill"></a>docker-compose kill</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker-compose kill [options] [SERVICE...] </span><br><span class="line">通过发送SIGKILL信号来强制停止服务容器。</span><br><span class="line">支持通过-s参数来指定发送的信号，例如通过如下指令发送SIGINT信号：</span><br><span class="line">docker-compose kill -s SIGINT</span><br></pre></td></tr></table></figure>


<h4 id="docker-compose-config"><a href="#docker-compose-config" class="headerlink" title="docker-compose config"></a>docker-compose config</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker-compose config [options] 验证并查看compose文件配置。</span><br><span class="line">选项包括：</span><br><span class="line">–resolve-image-digests 将镜像标签标记为摘要</span><br><span class="line">-q, –quiet 只验证配置，不输出。 当配置正确时，不输出任何内容，当文件配置错误，输出错误信息</span><br><span class="line">–services 打印服务名，一行一个</span><br><span class="line">–volumes 打印数据卷名，一行一个</span><br></pre></td></tr></table></figure>


<h4 id="docker-compose-create"><a href="#docker-compose-create" class="headerlink" title="docker-compose create"></a>docker-compose create</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker-compose create [options] [SERVICE...] 为服务创建容器。</span><br><span class="line">选项包括：</span><br><span class="line">–force-recreate：重新创建容器，即使配置和镜像没有改变，不兼容–no-recreate参数</span><br><span class="line">–no-recreate：如果容器已经存在，不需要重新创建，不兼容–force-recreate参数</span><br><span class="line">–no-build：不创建镜像，即使缺失</span><br><span class="line">–build：创建容器前，生成镜像</span><br></pre></td></tr></table></figure>


<h4 id="docker-compose-exec"><a href="#docker-compose-exec" class="headerlink" title="docker-compose exec"></a>docker-compose exec</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker-compose exec [options] SERVICE COMMAND [ARGS...]</span><br><span class="line">选项包括：</span><br><span class="line">-d 分离模式，后台运行命令。</span><br><span class="line">–privileged 获取特权。</span><br><span class="line">–user USER 指定运行的用户。</span><br><span class="line">-T 禁用分配TTY，默认docker-compose exec 分配TTY。</span><br><span class="line">–index=index，当一个服务拥有多个容器时，可通过该参数登陆到该服务下的任何服务，</span><br><span class="line">例如：docker-compose exec –index=1 web /bin/bash，web服务中包含多个容器</span><br></pre></td></tr></table></figure>


<h4 id="docker-compose-port"><a href="#docker-compose-port" class="headerlink" title="docker-compose port"></a>docker-compose port</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker-compose port [options] SERVICE PRIVATE_PORT</span><br><span class="line">显示某个容器端口所映射的公共端口。</span><br><span class="line">选项包括：</span><br><span class="line">–protocol=proto，指定端口协议，TCP（默认值）或者UDP</span><br><span class="line">–index=index，如果同意服务存在多个容器，指定命令对象容器的序号（默认为1）</span><br></pre></td></tr></table></figure>


<h4 id="docker-compose-push"><a href="#docker-compose-push" class="headerlink" title="docker-compose push"></a>docker-compose push</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose push [options] [SERVICE...] 推送服务依的镜像。</span><br><span class="line">选项包括：</span><br><span class="line">–ignore-push-failures 忽略推送镜像过程中的错误</span><br></pre></td></tr></table></figure>


<h4 id="docker-compose-stop-1"><a href="#docker-compose-stop-1" class="headerlink" title="docker-compose stop"></a>docker-compose stop</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop [options] [SERVICE...] </span><br><span class="line">停止运行的容器</span><br></pre></td></tr></table></figure>


<h4 id="docker-compose-uppause"><a href="#docker-compose-uppause" class="headerlink" title="docker-compose uppause"></a>docker-compose uppause</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose unpause [SERVICE...] </span><br><span class="line">恢复处于暂停状态中的服务。</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.zzonn.com/2020/04/15/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" data-id="clf0jcv74001p6ocxbzaxh48j" data-title="docker-compose常用命令" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/" rel="tag">docker</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Net/">.Net</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Other/">Other</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SQL/">SQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tool/">Tool</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/net/" rel="tag">.net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netcore/" rel="tag">.netcore</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Abp/" rel="tag">Abp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Blazor/" rel="tag">Blazor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Elasticsearch/" rel="tag">Elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go/" rel="tag">Go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tool/" rel="tag">Tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/code/" rel="tag">code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/" rel="tag">mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/" rel="tag">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sqlserver/" rel="tag">sqlserver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vs-code/" rel="tag">vs code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%8F%E6%8D%B7/" rel="tag">敏捷</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/net/" style="font-size: 20px;">.net</a> <a href="/tags/netcore/" style="font-size: 16.67px;">.netcore</a> <a href="/tags/Abp/" style="font-size: 10px;">Abp</a> <a href="/tags/Blazor/" style="font-size: 10px;">Blazor</a> <a href="/tags/C/" style="font-size: 16.67px;">C#</a> <a href="/tags/Elasticsearch/" style="font-size: 10px;">Elasticsearch</a> <a href="/tags/Git/" style="font-size: 13.33px;">Git</a> <a href="/tags/Go/" style="font-size: 10px;">Go</a> <a href="/tags/Tool/" style="font-size: 13.33px;">Tool</a> <a href="/tags/code/" style="font-size: 10px;">code</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/mongodb/" style="font-size: 10px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/redis/" style="font-size: 13.33px;">redis</a> <a href="/tags/sql/" style="font-size: 13.33px;">sql</a> <a href="/tags/sqlserver/" style="font-size: 10px;">sqlserver</a> <a href="/tags/vs-code/" style="font-size: 10px;">vs code</a> <a href="/tags/vue/" style="font-size: 13.33px;">vue</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 10px;">微服务</a> <a href="/tags/%E6%95%8F%E6%8D%B7/" style="font-size: 10px;">敏捷</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/05/28/%E8%BF%87%E6%97%A9%E7%9A%84%E7%BB%99%E6%96%B9%E6%B3%95%E4%B8%AD%20%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%20%E8%AE%BE%E4%B8%BA%20null%20%E5%8F%AF%E8%A2%AB%20GC%E6%8F%90%E5%89%8D%E5%9B%9E%E6%94%B6%E5%90%97%EF%BC%9F-%E8%BF%87%E6%97%A9%E7%9A%84%E7%BB%99%E6%96%B9%E6%B3%95%E4%B8%AD%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%E8%AE%BE%E4%B8%BAnull%E5%8F%AF%E8%A2%ABgc%E6%8F%90%E5%89%8D%E5%9B%9E%E6%94%B6%E5%90%97/">过早的给方法中 引用对象 设为 null 可被 GC提前回收吗？</a>
          </li>
        
          <li>
            <a href="/2022/05/28/Git%20%E4%B8%8D%E8%A6%81%E5%8F%AA%E4%BC%9A%20pull%20%E5%92%8C%20push%EF%BC%8C%E8%AF%95%E8%AF%95%E7%94%A8%E8%BF%99%E4%BA%9B%E5%91%BD%E4%BB%A4%E6%9D%A5%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87-git%E4%B8%8D%E8%A6%81%E5%8F%AA%E4%BC%9Apull%E5%92%8Cpush%E8%AF%95%E8%AF%95%E7%94%A8%E8%BF%99%E4%BA%9B%E5%91%BD%E4%BB%A4%E6%9D%A5%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87/">Git 不要只会 pull 和 push，试试用这些命令来提高效率</a>
          </li>
        
          <li>
            <a href="/2022/03/11/ClickHouse%E7%AE%80%E4%BB%8B-clickhouse%E7%AE%80%E4%BB%8B/">ClickHouse简介</a>
          </li>
        
          <li>
            <a href="/2022/03/04/%E5%8F%91%E5%B8%83.netcore%E9%A1%B9%E7%9B%AE%E5%88%B0linux-fa-bu-netcore-xiang-mu-dao-linux/">发布.netcore项目到linux</a>
          </li>
        
          <li>
            <a href="/2021/08/12/code%20review%20%E6%B5%81%E7%A8%8B%E8%A7%84%E8%8C%83-codereview%E6%B5%81%E7%A8%8B%E8%A7%84%E8%8C%83/">code review 流程规范</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 LiPan<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>